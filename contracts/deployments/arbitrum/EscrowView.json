{
  "address": "0xAf36da891c03b8A3a675f08f59355c8ff877330d",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_escrow",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "escrow",
      "outputs": [
        {
          "internalType": "contract EscrowUniversal",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_amountWei",
          "type": "uint256"
        }
      ],
      "name": "formatEth",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_amountWei",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_token",
          "type": "address"
        }
      ],
      "name": "formatToken",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_transactionID",
          "type": "uint256"
        }
      ],
      "name": "getPayoutMessages",
      "outputs": [
        {
          "internalType": "string",
          "name": "noWinner",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "buyerWins",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "sellerWins",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x8a0b9c61064046e717255944a2a566583693eb20461d9fc5ddbea955f0bf459c",
  "receipt": {
    "to": null,
    "from": "0xf1C7c037891525E360C59f708739Ac09A7670c59",
    "contractAddress": "0xAf36da891c03b8A3a675f08f59355c8ff877330d",
    "transactionIndex": 1,
    "gasUsed": "954672",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2da5d79176b5a548fb88d128c51075c6aa486f3f5097ed8234498850cefa7a6e",
    "transactionHash": "0x8a0b9c61064046e717255944a2a566583693eb20461d9fc5ddbea955f0bf459c",
    "logs": [],
    "blockNumber": 365386049,
    "cumulativeGasUsed": "954672",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x5D64Cb92c351e46615ce427015A2F1E0823A2402"
  ],
  "numDeployments": 2,
  "solcInputHash": "234d8a9dc1e449f845d4656dd31ae023",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_escrow\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"escrow\",\"outputs\":[{\"internalType\":\"contract EscrowUniversal\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountWei\",\"type\":\"uint256\"}],\"name\":\"formatEth\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountWei\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"formatToken\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_transactionID\",\"type\":\"uint256\"}],\"name\":\"getPayoutMessages\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"noWinner\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"buyerWins\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sellerWins\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"_escrow\":\"The address of the EscrowUniversal contract.\"}},\"formatEth(uint256)\":{\"params\":{\"_amountWei\":\"The amount in wei.\"},\"returns\":{\"_0\":\"The formatted amount.\"}},\"formatToken(uint256,address)\":{\"params\":{\"_amountWei\":\"The amount in wei.\",\"_token\":\"The address of the token.\"},\"returns\":{\"_0\":\"The formatted amount.\"}},\"getPayoutMessages(uint256)\":{\"returns\":{\"buyerWins\":\"The payout message for the case where the buyer wins.\",\"noWinner\":\"The payout message for the case where nobody wins.\",\"sellerWins\":\"The payout message for the case where the seller wins.\"}}},\"title\":\"EscrowView\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"Initialize the view contract with the address of the EscrowUniversal contract.\"},\"formatEth(uint256)\":{\"notice\":\"Format an amount in ETH to 3 decimal places.\"},\"formatToken(uint256,address)\":{\"notice\":\"Format an amount in a token to 3 decimal places.\"},\"getPayoutMessages(uint256)\":{\"notice\":\"Get the payout messages for a transaction *once* a dispute is created.The amounts are exclusive of arbitration fees for clarity.The amounts pre-dispute are imprecise as the arbitration fees are not paid yet by either or both parties.\"}},\"notice\":\"A view contract for EscrowUniversal to facilitate the display of ruling options.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/EscrowView.sol\":\"EscrowView\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@kleros/kleros-v2-contracts/arbitration/interfaces/IArbitrableV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.24;\\n\\nimport \\\"./IArbitratorV2.sol\\\";\\n\\n/// @title IArbitrableV2\\n/// @notice Arbitrable interface.\\n/// @dev When developing arbitrable contracts, we need to:\\n/// - Define the action taken when a ruling is received by the contract.\\n/// - Allow dispute creation. For this a function must call arbitrator.createDispute{value: _fee}(_choices,_extraData);\\ninterface IArbitrableV2 {\\n    /// @dev To be emitted when a dispute is created to link the correct meta-evidence to the disputeID.\\n    /// @param _arbitrator The arbitrator of the contract.\\n    /// @param _arbitratorDisputeID The identifier of the dispute in the Arbitrator contract.\\n    /// @param _externalDisputeID An identifier created outside Kleros by the protocol requesting arbitration.\\n    /// @param _templateId The identifier of the dispute template. Should not be used with _templateUri.\\n    /// @param _templateUri The URI to the dispute template. For example on IPFS: starting with '/ipfs/'. Should not be used with _templateId.\\n    event DisputeRequest(\\n        IArbitratorV2 indexed _arbitrator,\\n        uint256 indexed _arbitratorDisputeID,\\n        uint256 _externalDisputeID,\\n        uint256 _templateId,\\n        string _templateUri\\n    );\\n\\n    /// @dev To be raised when a ruling is given.\\n    /// @param _arbitrator The arbitrator giving the ruling.\\n    /// @param _disputeID The identifier of the dispute in the Arbitrator contract.\\n    /// @param _ruling The ruling which was given.\\n    event Ruling(IArbitratorV2 indexed _arbitrator, uint256 indexed _disputeID, uint256 _ruling);\\n\\n    /// @dev Give a ruling for a dispute.\\n    ///      Must be called by the arbitrator.\\n    ///      The purpose of this function is to ensure that the address calling it has the right to rule on the contract.\\n    /// @param _disputeID The identifier of the dispute in the Arbitrator contract.\\n    /// @param _ruling Ruling given by the arbitrator.\\n    /// Note that 0 is reserved for \\\"Not able/wanting to make a decision\\\".\\n    function rule(uint256 _disputeID, uint256 _ruling) external;\\n}\\n\",\"keccak256\":\"0x054fd09cc201ddca3d92a07169fb86b9db21a510a2a0f15ac4b6dffd900079fe\",\"license\":\"MIT\"},\"@kleros/kleros-v2-contracts/arbitration/interfaces/IArbitratorV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.24;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./IArbitrableV2.sol\\\";\\n\\n/// @title Arbitrator\\n/// Arbitrator interface that implements the new arbitration standard.\\n/// Unlike the ERC-792 this standard is not concerned with appeals, so each arbitrator can implement an appeal system that suits it the most.\\n/// When developing arbitrator contracts we need to:\\n/// - Define the functions for dispute creation (createDispute). Don't forget to store the arbitrated contract and the disputeID (which should be unique, may nbDisputes).\\n/// - Define the functions for cost display (arbitrationCost).\\n/// - Allow giving rulings. For this a function must call arbitrable.rule(disputeID, ruling).\\ninterface IArbitratorV2 {\\n    /// @dev To be emitted when a dispute is created.\\n    /// @param _disputeID The identifier of the dispute in the Arbitrator contract.\\n    /// @param _arbitrable The contract which created the dispute.\\n    event DisputeCreation(uint256 indexed _disputeID, IArbitrableV2 indexed _arbitrable);\\n\\n    /// @dev To be raised when a ruling is given.\\n    /// @param _arbitrable The arbitrable receiving the ruling.\\n    /// @param _disputeID The identifier of the dispute in the Arbitrator contract.\\n    /// @param _ruling The ruling which was given.\\n    event Ruling(IArbitrableV2 indexed _arbitrable, uint256 indexed _disputeID, uint256 _ruling);\\n\\n    /// @dev To be emitted when an ERC20 token is added or removed as a method to pay fees.\\n    /// @param _token The ERC20 token.\\n    /// @param _accepted Whether the token is accepted or not.\\n    event AcceptedFeeToken(IERC20 indexed _token, bool indexed _accepted);\\n\\n    /// @dev To be emitted when the fee for a particular ERC20 token is updated.\\n    /// @param _feeToken The ERC20 token.\\n    /// @param _rateInEth The new rate of the fee token in ETH.\\n    /// @param _rateDecimals The new decimals of the fee token rate.\\n    event NewCurrencyRate(IERC20 indexed _feeToken, uint64 _rateInEth, uint8 _rateDecimals);\\n\\n    /// @dev Create a dispute and pay for the fees in the native currency, typically ETH.\\n    ///      Must be called by the arbitrable contract.\\n    ///      Must pay at least arbitrationCost(_extraData).\\n    /// @param _numberOfChoices The number of choices the arbitrator can choose from in this dispute.\\n    /// @param _extraData Additional info about the dispute. We use it to pass the ID of the dispute's court (first 32 bytes), the minimum number of jurors required (next 32 bytes) and the ID of the specific dispute kit (last 32 bytes).\\n    /// @return disputeID The identifier of the dispute created.\\n    function createDispute(\\n        uint256 _numberOfChoices,\\n        bytes calldata _extraData\\n    ) external payable returns (uint256 disputeID);\\n\\n    /// @dev Create a dispute and pay for the fees in a supported ERC20 token.\\n    ///      Must be called by the arbitrable contract.\\n    ///      Must pay at least arbitrationCost(_extraData).\\n    /// @param _numberOfChoices The number of choices the arbitrator can choose from in this dispute.\\n    /// @param _extraData Additional info about the dispute. We use it to pass the ID of the dispute's court (first 32 bytes), the minimum number of jurors required (next 32 bytes) and the ID of the specific dispute kit (last 32 bytes).\\n    /// @param _feeToken The ERC20 token used to pay fees.\\n    /// @param _feeAmount Amount of the ERC20 token used to pay fees.\\n    /// @return disputeID The identifier of the dispute created.\\n    function createDispute(\\n        uint256 _numberOfChoices,\\n        bytes calldata _extraData,\\n        IERC20 _feeToken,\\n        uint256 _feeAmount\\n    ) external returns (uint256 disputeID);\\n\\n    /// @dev Compute the cost of arbitration denominated in the native currency, typically ETH.\\n    ///      It is recommended not to increase it often, as it can be highly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\\n    /// @param _extraData Additional info about the dispute. We use it to pass the ID of the dispute's court (first 32 bytes), the minimum number of jurors required (next 32 bytes) and the ID of the specific dispute kit (last 32 bytes).\\n    /// @return cost The arbitration cost in ETH.\\n    function arbitrationCost(bytes calldata _extraData) external view returns (uint256 cost);\\n\\n    /// @dev Compute the cost of arbitration denominated in `_feeToken`.\\n    ///      It is recommended not to increase it often, as it can be highly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\\n    /// @param _extraData Additional info about the dispute. We use it to pass the ID of the dispute's court (first 32 bytes), the minimum number of jurors required (next 32 bytes) and the ID of the specific dispute kit (last 32 bytes).\\n    /// @param _feeToken The ERC20 token used to pay fees.\\n    /// @return cost The arbitration cost in `_feeToken`.\\n    function arbitrationCost(bytes calldata _extraData, IERC20 _feeToken) external view returns (uint256 cost);\\n\\n    /// @dev Gets the current ruling of a specified dispute.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @return ruling The current ruling.\\n    /// @return tied Whether it's a tie or not.\\n    /// @return overridden Whether the ruling was overridden by appeal funding or not.\\n    function currentRuling(uint256 _disputeID) external view returns (uint256 ruling, bool tied, bool overridden);\\n}\\n\",\"keccak256\":\"0xfc7cc82c1431720da41aeb1a181171f10466b5d0d280db7aa37c451681185493\",\"license\":\"MIT\"},\"@kleros/kleros-v2-contracts/arbitration/interfaces/IDisputeTemplateRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.24;\\n\\n/// @title IDisputeTemplate\\n/// @notice Dispute Template interface.\\ninterface IDisputeTemplateRegistry {\\n    /// @dev To be emitted when a new dispute template is created.\\n    /// @param _templateId The identifier of the dispute template.\\n    /// @param _templateTag An optional tag for the dispute template, such as \\\"registration\\\" or \\\"removal\\\".\\n    /// @param _templateData The template data.\\n    /// @param _templateDataMappings The data mappings.\\n    event DisputeTemplate(\\n        uint256 indexed _templateId,\\n        string indexed _templateTag,\\n        string _templateData,\\n        string _templateDataMappings\\n    );\\n\\n    function setDisputeTemplate(\\n        string memory _templateTag,\\n        string memory _templateData,\\n        string memory _templateDataMappings\\n    ) external returns (uint256 templateId);\\n}\\n\",\"keccak256\":\"0xd8122941175d1d5c2983e71717a2fdcc6fe94aa9de08f87eb7c44e3a5f1c2030\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x70f2f713b13b7ce4610bcd0ac9fec0f3cc43693b043abcb8dc40a42a726eb330\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Panic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Helper library for emitting standardized panic codes.\\n *\\n * ```solidity\\n * contract Example {\\n *      using Panic for uint256;\\n *\\n *      // Use any of the declared internal constants\\n *      function foo() { Panic.GENERIC.panic(); }\\n *\\n *      // Alternatively\\n *      function foo() { Panic.panic(Panic.GENERIC); }\\n * }\\n * ```\\n *\\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\\n *\\n * _Available since v5.1._\\n */\\n// slither-disable-next-line unused-state\\nlibrary Panic {\\n    /// @dev generic / unspecified error\\n    uint256 internal constant GENERIC = 0x00;\\n    /// @dev used by the assert() builtin\\n    uint256 internal constant ASSERT = 0x01;\\n    /// @dev arithmetic underflow or overflow\\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\\n    /// @dev division or modulo by zero\\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\\n    /// @dev enum conversion error\\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\\n    /// @dev invalid encoding in storage\\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\\n    /// @dev empty array pop\\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\\n    /// @dev array out of bounds access\\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\\n    /// @dev resource error (too large allocation or too large array)\\n    uint256 internal constant RESOURCE_ERROR = 0x41;\\n    /// @dev calling invalid internal function\\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\\n\\n    /// @dev Reverts with a panic code. Recommended to use with\\n    /// the internal constants with predefined codes.\\n    function panic(uint256 code) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, 0x4e487b71)\\n            mstore(0x20, code)\\n            revert(0x1c, 0x24)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf7fe324703a64fc51702311dc51562d5cb1497734f074e4f483bfb6717572d7a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SafeCast} from \\\"./math/SafeCast.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    using SafeCast for *;\\n\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\\n        (1 << 0x08) | // backspace\\n            (1 << 0x09) | // tab\\n            (1 << 0x0a) | // newline\\n            (1 << 0x0c) | // form feed\\n            (1 << 0x0d) | // carriage return\\n            (1 << 0x22) | // double quote\\n            (1 << 0x5c); // backslash\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev The string being parsed contains characters that are not in scope of the given base.\\n     */\\n    error StringsInvalidChar();\\n\\n    /**\\n     * @dev The string being parsed is not a properly formatted address.\\n     */\\n    error StringsInvalidAddressFormat();\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            assembly (\\\"memory-safe\\\") {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                assembly (\\\"memory-safe\\\") {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\\n     * representation, according to EIP-55.\\n     */\\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\\n        bytes memory buffer = bytes(toHexString(addr));\\n\\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\\n        uint256 hashValue;\\n        assembly (\\\"memory-safe\\\") {\\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\\n        }\\n\\n        for (uint256 i = 41; i > 1; --i) {\\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\\n                // case shift by xoring with 0x20\\n                buffer[i] ^= 0x20;\\n            }\\n            hashValue >>= 4;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n\\n    /**\\n     * @dev Parse a decimal string and returns the value as a `uint256`.\\n     *\\n     * Requirements:\\n     * - The string must be formatted as `[0-9]*`\\n     * - The result must fit into an `uint256` type\\n     */\\n    function parseUint(string memory input) internal pure returns (uint256) {\\n        return parseUint(input, 0, bytes(input).length);\\n    }\\n\\n    /**\\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\\n     * `end` (excluded).\\n     *\\n     * Requirements:\\n     * - The substring must be formatted as `[0-9]*`\\n     * - The result must fit into an `uint256` type\\n     */\\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\\n        if (!success) revert StringsInvalidChar();\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\\n     *\\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\\n     */\\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\\n    }\\n\\n    /**\\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\\n     * character.\\n     *\\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\\n     */\\n    function tryParseUint(\\n        string memory input,\\n        uint256 begin,\\n        uint256 end\\n    ) internal pure returns (bool success, uint256 value) {\\n        if (end > bytes(input).length || begin > end) return (false, 0);\\n        return _tryParseUintUncheckedBounds(input, begin, end);\\n    }\\n\\n    /**\\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\\n     */\\n    function _tryParseUintUncheckedBounds(\\n        string memory input,\\n        uint256 begin,\\n        uint256 end\\n    ) private pure returns (bool success, uint256 value) {\\n        bytes memory buffer = bytes(input);\\n\\n        uint256 result = 0;\\n        for (uint256 i = begin; i < end; ++i) {\\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\\n            if (chr > 9) return (false, 0);\\n            result *= 10;\\n            result += chr;\\n        }\\n        return (true, result);\\n    }\\n\\n    /**\\n     * @dev Parse a decimal string and returns the value as a `int256`.\\n     *\\n     * Requirements:\\n     * - The string must be formatted as `[-+]?[0-9]*`\\n     * - The result must fit in an `int256` type.\\n     */\\n    function parseInt(string memory input) internal pure returns (int256) {\\n        return parseInt(input, 0, bytes(input).length);\\n    }\\n\\n    /**\\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\\n     * `end` (excluded).\\n     *\\n     * Requirements:\\n     * - The substring must be formatted as `[-+]?[0-9]*`\\n     * - The result must fit in an `int256` type.\\n     */\\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\\n        (bool success, int256 value) = tryParseInt(input, begin, end);\\n        if (!success) revert StringsInvalidChar();\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\\n     * the result does not fit in a `int256`.\\n     *\\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\\n     */\\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\\n    }\\n\\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\\n\\n    /**\\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\\n     * character or if the result does not fit in a `int256`.\\n     *\\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\\n     */\\n    function tryParseInt(\\n        string memory input,\\n        uint256 begin,\\n        uint256 end\\n    ) internal pure returns (bool success, int256 value) {\\n        if (end > bytes(input).length || begin > end) return (false, 0);\\n        return _tryParseIntUncheckedBounds(input, begin, end);\\n    }\\n\\n    /**\\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\\n     */\\n    function _tryParseIntUncheckedBounds(\\n        string memory input,\\n        uint256 begin,\\n        uint256 end\\n    ) private pure returns (bool success, int256 value) {\\n        bytes memory buffer = bytes(input);\\n\\n        // Check presence of a negative sign.\\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\\n        bool positiveSign = sign == bytes1(\\\"+\\\");\\n        bool negativeSign = sign == bytes1(\\\"-\\\");\\n        uint256 offset = (positiveSign || negativeSign).toUint();\\n\\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\\n\\n        if (absSuccess && absValue < ABS_MIN_INT256) {\\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\\n            return (true, type(int256).min);\\n        } else return (false, 0);\\n    }\\n\\n    /**\\n     * @dev Parse a hexadecimal string (with or without \\\"0x\\\" prefix), and returns the value as a `uint256`.\\n     *\\n     * Requirements:\\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\\n     * - The result must fit in an `uint256` type.\\n     */\\n    function parseHexUint(string memory input) internal pure returns (uint256) {\\n        return parseHexUint(input, 0, bytes(input).length);\\n    }\\n\\n    /**\\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\\n     * `end` (excluded).\\n     *\\n     * Requirements:\\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\\n     * - The result must fit in an `uint256` type.\\n     */\\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\\n        if (!success) revert StringsInvalidChar();\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\\n     *\\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\\n     */\\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\\n    }\\n\\n    /**\\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\\n     * invalid character.\\n     *\\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\\n     */\\n    function tryParseHexUint(\\n        string memory input,\\n        uint256 begin,\\n        uint256 end\\n    ) internal pure returns (bool success, uint256 value) {\\n        if (end > bytes(input).length || begin > end) return (false, 0);\\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\\n    }\\n\\n    /**\\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\\n     */\\n    function _tryParseHexUintUncheckedBounds(\\n        string memory input,\\n        uint256 begin,\\n        uint256 end\\n    ) private pure returns (bool success, uint256 value) {\\n        bytes memory buffer = bytes(input);\\n\\n        // skip 0x prefix if present\\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\\\"0x\\\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\\n        uint256 offset = hasPrefix.toUint() * 2;\\n\\n        uint256 result = 0;\\n        for (uint256 i = begin + offset; i < end; ++i) {\\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\\n            if (chr > 15) return (false, 0);\\n            result *= 16;\\n            unchecked {\\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\\n                result += chr;\\n            }\\n        }\\n        return (true, result);\\n    }\\n\\n    /**\\n     * @dev Parse a hexadecimal string (with or without \\\"0x\\\" prefix), and returns the value as an `address`.\\n     *\\n     * Requirements:\\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\\n     */\\n    function parseAddress(string memory input) internal pure returns (address) {\\n        return parseAddress(input, 0, bytes(input).length);\\n    }\\n\\n    /**\\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\\n     * `end` (excluded).\\n     *\\n     * Requirements:\\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\\n     */\\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\\n        (bool success, address value) = tryParseAddress(input, begin, end);\\n        if (!success) revert StringsInvalidAddressFormat();\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\\n     * formatted address. See {parseAddress-string} requirements.\\n     */\\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\\n        return tryParseAddress(input, 0, bytes(input).length);\\n    }\\n\\n    /**\\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\\n     */\\n    function tryParseAddress(\\n        string memory input,\\n        uint256 begin,\\n        uint256 end\\n    ) internal pure returns (bool success, address value) {\\n        if (end > bytes(input).length || begin > end) return (false, address(0));\\n\\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\\\"0x\\\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\\n\\n        // check that input is the correct length\\n        if (end - begin == expectedLength) {\\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\\n            return (s, address(uint160(v)));\\n        } else {\\n            return (false, address(0));\\n        }\\n    }\\n\\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\\n        uint8 value = uint8(chr);\\n\\n        // Try to parse `chr`:\\n        // - Case 1: [0-9]\\n        // - Case 2: [a-f]\\n        // - Case 3: [A-F]\\n        // - otherwise not supported\\n        unchecked {\\n            if (value > 47 && value < 58) value -= 48;\\n            else if (value > 96 && value < 103) value -= 87;\\n            else if (value > 64 && value < 71) value -= 55;\\n            else return type(uint8).max;\\n        }\\n\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\\n     *\\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\\n     *\\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\\n     * characters that are not in this range, but other tooling may provide different results.\\n     */\\n    function escapeJSON(string memory input) internal pure returns (string memory) {\\n        bytes memory buffer = bytes(input);\\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\\n        uint256 outputLength = 0;\\n\\n        for (uint256 i; i < buffer.length; ++i) {\\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\\n                output[outputLength++] = \\\"\\\\\\\\\\\";\\n                if (char == 0x08) output[outputLength++] = \\\"b\\\";\\n                else if (char == 0x09) output[outputLength++] = \\\"t\\\";\\n                else if (char == 0x0a) output[outputLength++] = \\\"n\\\";\\n                else if (char == 0x0c) output[outputLength++] = \\\"f\\\";\\n                else if (char == 0x0d) output[outputLength++] = \\\"r\\\";\\n                else if (char == 0x5c) output[outputLength++] = \\\"\\\\\\\\\\\";\\n                else if (char == 0x22) {\\n                    // solhint-disable-next-line quotes\\n                    output[outputLength++] = '\\\"';\\n                }\\n            } else {\\n                output[outputLength++] = char;\\n            }\\n        }\\n        // write the actual length and deallocate unused memory\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(output, outputLength)\\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\\n        }\\n\\n        return string(output);\\n    }\\n\\n    /**\\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\\n     *\\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\\n     * assembly block as such would prevent some optimizations.\\n     */\\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\\n        assembly (\\\"memory-safe\\\") {\\n            value := mload(add(buffer, add(0x20, offset)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x81c274a60a7ae232ae3dc9ff3a4011b4849a853c13b0832cd3351bb1bb2f0dae\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Panic} from \\\"../Panic.sol\\\";\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Return the 512-bit addition of two uint256.\\n     *\\n     * The result is stored in two 256 variables such that sum = high * 2\\u00b2\\u2075\\u2076 + low.\\n     */\\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\\n        assembly (\\\"memory-safe\\\") {\\n            low := add(a, b)\\n            high := lt(low, a)\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the 512-bit multiplication of two uint256.\\n     *\\n     * The result is stored in two 256 variables such that product = high * 2\\u00b2\\u2075\\u2076 + low.\\n     */\\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2\\u00b2\\u2075\\u2076 and mod 2\\u00b2\\u2075\\u2076 - 1, then use\\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = high * 2\\u00b2\\u2075\\u2076 + low.\\n        assembly (\\\"memory-safe\\\") {\\n            let mm := mulmod(a, b, not(0))\\n            low := mul(a, b)\\n            high := sub(sub(mm, low), lt(mm, low))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a + b;\\n            success = c >= a;\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a - b;\\n            success = c <= a;\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a * b;\\n            assembly (\\\"memory-safe\\\") {\\n                // Only true when the multiplication doesn't overflow\\n                // (c / a == b) || (a == 0)\\n                success := or(eq(div(c, a), b), iszero(a))\\n            }\\n            // equivalent to: success ? c : 0\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            success = b > 0;\\n            assembly (\\\"memory-safe\\\") {\\n                // The `DIV` opcode returns zero when the denominator is 0.\\n                result := div(a, b)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            success = b > 0;\\n            assembly (\\\"memory-safe\\\") {\\n                // The `MOD` opcode returns zero when the denominator is 0.\\n                result := mod(a, b)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating addition, bounds to `2\\u00b2\\u2075\\u2076 - 1` instead of overflowing.\\n     */\\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (bool success, uint256 result) = tryAdd(a, b);\\n        return ternary(success, result, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\\n     */\\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (, uint256 result) = trySub(a, b);\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating multiplication, bounds to `2\\u00b2\\u2075\\u2076 - 1` instead of overflowing.\\n     */\\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (bool success, uint256 result) = tryMul(a, b);\\n        return ternary(success, result, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\\n     *\\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\\n     * one branch when needed, making this function more expensive.\\n     */\\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            // branchless ternary works because:\\n            // b ^ (a ^ b) == a\\n            // b ^ 0 == b\\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return ternary(a > b, a, b);\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return ternary(a < b, a, b);\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n\\n        // The following calculation ensures accurate ceiling division without overflow.\\n        // Since a is non-zero, (a - 1) / b will not overflow.\\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\\n        // when a = type(uint256).max and b = 1.\\n        unchecked {\\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     *\\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            (uint256 high, uint256 low) = mul512(x, y);\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (high == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return low / denominator;\\n            }\\n\\n            // Make sure the result is less than 2\\u00b2\\u2075\\u2076. Also prevents denominator == 0.\\n            if (denominator <= high) {\\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [high low].\\n            uint256 remainder;\\n            assembly (\\\"memory-safe\\\") {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                high := sub(high, gt(remainder, low))\\n                low := sub(low, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly (\\\"memory-safe\\\") {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [high low] by twos.\\n                low := div(low, twos)\\n\\n                // Flip twos such that it is 2\\u00b2\\u2075\\u2076 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from high into low.\\n            low |= high * twos;\\n\\n            // Invert denominator mod 2\\u00b2\\u2075\\u2076. Now that denominator is an odd number, it has an inverse modulo 2\\u00b2\\u2075\\u2076 such\\n            // that denominator * inv \\u2261 1 mod 2\\u00b2\\u2075\\u2076. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv \\u2261 1 mod 2\\u2074.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u2078\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u00b9\\u2076\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u00b3\\u00b2\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u2076\\u2074\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u00b9\\u00b2\\u2078\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u00b2\\u2075\\u2076\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2\\u00b2\\u2075\\u2076. Since the preconditions guarantee that the outcome is\\n            // less than 2\\u00b2\\u2075\\u2076, this is the final result. We don't need to compute the high bits of the result and high\\n            // is no longer required.\\n            result = low * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\\n    }\\n\\n    /**\\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\\n     */\\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\\n        unchecked {\\n            (uint256 high, uint256 low) = mul512(x, y);\\n            if (high >= 1 << n) {\\n                Panic.panic(Panic.UNDER_OVERFLOW);\\n            }\\n            return (high << (256 - n)) | (low >> n);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\\n     */\\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\\n    }\\n\\n    /**\\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\\n     *\\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\\n     *\\n     * If the input value is not inversible, 0 is returned.\\n     *\\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\\n     */\\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\\n        unchecked {\\n            if (n == 0) return 0;\\n\\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\\n            // ax + ny = 1\\n            // ax = 1 + (-y)n\\n            // ax \\u2261 1 (mod n) # x is the inverse of a modulo n\\n\\n            // If the remainder is 0 the gcd is n right away.\\n            uint256 remainder = a % n;\\n            uint256 gcd = n;\\n\\n            // Therefore the initial coefficients are:\\n            // ax + ny = gcd(a, n) = n\\n            // 0a + 1n = n\\n            int256 x = 0;\\n            int256 y = 1;\\n\\n            while (remainder != 0) {\\n                uint256 quotient = gcd / remainder;\\n\\n                (gcd, remainder) = (\\n                    // The old remainder is the next gcd to try.\\n                    remainder,\\n                    // Compute the next remainder.\\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\\n                    // where gcd is at most n (capped to type(uint256).max)\\n                    gcd - remainder * quotient\\n                );\\n\\n                (x, y) = (\\n                    // Increment the coefficient of a.\\n                    y,\\n                    // Decrement the coefficient of n.\\n                    // Can overflow, but the result is casted to uint256 so that the\\n                    // next value of y is \\\"wrapped around\\\" to a value between 0 and n - 1.\\n                    x - y * int256(quotient)\\n                );\\n            }\\n\\n            if (gcd != 1) return 0; // No inverse exists.\\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\\n        }\\n    }\\n\\n    /**\\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\\n     *\\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\\n     * prime, then `a**(p-1) \\u2261 1 mod p`. As a consequence, we have `a * a**(p-2) \\u2261 1 mod p`, which means that\\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\\n     *\\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\\n     */\\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\\n        unchecked {\\n            return Math.modExp(a, p - 2, p);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\\n     *\\n     * Requirements:\\n     * - modulus can't be zero\\n     * - underlying staticcall to precompile must succeed\\n     *\\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\\n     * interpreted as 0.\\n     */\\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\\n        (bool success, uint256 result) = tryModExp(b, e, m);\\n        if (!success) {\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\\n     * to operate modulo 0 or if the underlying precompile reverted.\\n     *\\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\\n     * of a revert, but the result may be incorrectly interpreted as 0.\\n     */\\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\\n        if (m == 0) return (false, 0);\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40)\\n            // | Offset    | Content    | Content (Hex)                                                      |\\n            // |-----------|------------|--------------------------------------------------------------------|\\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\\n            mstore(ptr, 0x20)\\n            mstore(add(ptr, 0x20), 0x20)\\n            mstore(add(ptr, 0x40), 0x20)\\n            mstore(add(ptr, 0x60), b)\\n            mstore(add(ptr, 0x80), e)\\n            mstore(add(ptr, 0xa0), m)\\n\\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\\n            // so we can use the memory scratch space located at offset 0.\\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /**\\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\\n     */\\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\\n        (bool success, bytes memory result) = tryModExp(b, e, m);\\n        if (!success) {\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\\n     */\\n    function tryModExp(\\n        bytes memory b,\\n        bytes memory e,\\n        bytes memory m\\n    ) internal view returns (bool success, bytes memory result) {\\n        if (_zeroBytes(m)) return (false, new bytes(0));\\n\\n        uint256 mLen = m.length;\\n\\n        // Encode call args in result and move the free memory pointer\\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\\n\\n        assembly (\\\"memory-safe\\\") {\\n            let dataPtr := add(result, 0x20)\\n            // Write result on top of args to avoid allocating extra memory.\\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\\n            // Overwrite the length.\\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\\n            mstore(result, mLen)\\n            // Set the memory pointer after the returned data.\\n            mstore(0x40, add(dataPtr, mLen))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether the provided byte array is zero.\\n     */\\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\\n        for (uint256 i = 0; i < byteArray.length; ++i) {\\n            if (byteArray[i] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\\n     * using integer operations.\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        unchecked {\\n            // Take care of easy edge cases when a == 0 or a == 1\\n            if (a <= 1) {\\n                return a;\\n            }\\n\\n            // In this function, we use Newton's method to get a root of `f(x) := x\\u00b2 - a`. It involves building a\\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\\n            // the current value as `\\u03b5_n = | x_n - sqrt(a) |`.\\n            //\\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\\n            // of the target. (i.e. `2**(e-1) \\u2264 sqrt(a) < 2**e`). We know that `e \\u2264 128` because `(2\\u00b9\\u00b2\\u2078)\\u00b2 = 2\\u00b2\\u2075\\u2076` is\\n            // bigger than any uint256.\\n            //\\n            // By noticing that\\n            // `2**(e-1) \\u2264 sqrt(a) < 2**e \\u2192 (2**(e-1))\\u00b2 \\u2264 a < (2**e)\\u00b2 \\u2192 2**(2*e-2) \\u2264 a < 2**(2*e)`\\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\\n            // to the msb function.\\n            uint256 aa = a;\\n            uint256 xn = 1;\\n\\n            if (aa >= (1 << 128)) {\\n                aa >>= 128;\\n                xn <<= 64;\\n            }\\n            if (aa >= (1 << 64)) {\\n                aa >>= 64;\\n                xn <<= 32;\\n            }\\n            if (aa >= (1 << 32)) {\\n                aa >>= 32;\\n                xn <<= 16;\\n            }\\n            if (aa >= (1 << 16)) {\\n                aa >>= 16;\\n                xn <<= 8;\\n            }\\n            if (aa >= (1 << 8)) {\\n                aa >>= 8;\\n                xn <<= 4;\\n            }\\n            if (aa >= (1 << 4)) {\\n                aa >>= 4;\\n                xn <<= 2;\\n            }\\n            if (aa >= (1 << 2)) {\\n                xn <<= 1;\\n            }\\n\\n            // We now have x_n such that `x_n = 2**(e-1) \\u2264 sqrt(a) < 2**e = 2 * x_n`. This implies \\u03b5_n \\u2264 2**(e-1).\\n            //\\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to \\u03b5_n \\u2264 2**(e-2).\\n            // This is going to be our x_0 (and \\u03b5_0)\\n            xn = (3 * xn) >> 1; // \\u03b5_0 := | x_0 - sqrt(a) | \\u2264 2**(e-2)\\n\\n            // From here, Newton's method give us:\\n            // x_{n+1} = (x_n + a / x_n) / 2\\n            //\\n            // One should note that:\\n            // x_{n+1}\\u00b2 - a = ((x_n + a / x_n) / 2)\\u00b2 - a\\n            //              = ((x_n\\u00b2 + a) / (2 * x_n))\\u00b2 - a\\n            //              = (x_n\\u2074 + 2 * a * x_n\\u00b2 + a\\u00b2) / (4 * x_n\\u00b2) - a\\n            //              = (x_n\\u2074 + 2 * a * x_n\\u00b2 + a\\u00b2 - 4 * a * x_n\\u00b2) / (4 * x_n\\u00b2)\\n            //              = (x_n\\u2074 - 2 * a * x_n\\u00b2 + a\\u00b2) / (4 * x_n\\u00b2)\\n            //              = (x_n\\u00b2 - a)\\u00b2 / (2 * x_n)\\u00b2\\n            //              = ((x_n\\u00b2 - a) / (2 * x_n))\\u00b2\\n            //              \\u2265 0\\n            // Which proves that for all n \\u2265 1, sqrt(a) \\u2264 x_n\\n            //\\n            // This gives us the proof of quadratic convergence of the sequence:\\n            // \\u03b5_{n+1} = | x_{n+1} - sqrt(a) |\\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\\n            //         = | (x_n\\u00b2 + a - 2*x_n*sqrt(a)) / (2 * x_n) |\\n            //         = | (x_n - sqrt(a))\\u00b2 / (2 * x_n) |\\n            //         = | \\u03b5_n\\u00b2 / (2 * x_n) |\\n            //         = \\u03b5_n\\u00b2 / | (2 * x_n) |\\n            //\\n            // For the first iteration, we have a special case where x_0 is known:\\n            // \\u03b5_1 = \\u03b5_0\\u00b2 / | (2 * x_0) |\\n            //     \\u2264 (2**(e-2))\\u00b2 / (2 * (2**(e-1) + 2**(e-2)))\\n            //     \\u2264 2**(2*e-4) / (3 * 2**(e-1))\\n            //     \\u2264 2**(e-3) / 3\\n            //     \\u2264 2**(e-3-log2(3))\\n            //     \\u2264 2**(e-4.5)\\n            //\\n            // For the following iterations, we use the fact that, 2**(e-1) \\u2264 sqrt(a) \\u2264 x_n:\\n            // \\u03b5_{n+1} = \\u03b5_n\\u00b2 / | (2 * x_n) |\\n            //         \\u2264 (2**(e-k))\\u00b2 / (2 * 2**(e-1))\\n            //         \\u2264 2**(2*e-2*k) / 2**e\\n            //         \\u2264 2**(e-2*k)\\n            xn = (xn + a / xn) >> 1; // \\u03b5_1 := | x_1 - sqrt(a) | \\u2264 2**(e-4.5)  -- special case, see above\\n            xn = (xn + a / xn) >> 1; // \\u03b5_2 := | x_2 - sqrt(a) | \\u2264 2**(e-9)    -- general case with k = 4.5\\n            xn = (xn + a / xn) >> 1; // \\u03b5_3 := | x_3 - sqrt(a) | \\u2264 2**(e-18)   -- general case with k = 9\\n            xn = (xn + a / xn) >> 1; // \\u03b5_4 := | x_4 - sqrt(a) | \\u2264 2**(e-36)   -- general case with k = 18\\n            xn = (xn + a / xn) >> 1; // \\u03b5_5 := | x_5 - sqrt(a) | \\u2264 2**(e-72)   -- general case with k = 36\\n            xn = (xn + a / xn) >> 1; // \\u03b5_6 := | x_6 - sqrt(a) | \\u2264 2**(e-144)  -- general case with k = 72\\n\\n            // Because e \\u2264 128 (as discussed during the first estimation phase), we know have reached a precision\\n            // \\u03b5_6 \\u2264 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\\n            // sqrt(a) or sqrt(a) + 1.\\n            return xn - SafeCast.toUint(xn > a / xn);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        // If value has upper 128 bits set, log2 result is at least 128\\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\\n        // If upper 64 bits of 128-bit half set, add 64 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\\n        // If upper 32 bits of 64-bit half set, add 32 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\\n        // If upper 16 bits of 32-bit half set, add 16 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\\n        // If upper 8 bits of 16-bit half set, add 8 to result\\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\\n        // If upper 4 bits of 8-bit half set, add 4 to result\\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\\n\\n        // Shifts value right by the current result and use it as an index into this lookup table:\\n        //\\n        // | x (4 bits) |  index  | table[index] = MSB position |\\n        // |------------|---------|-----------------------------|\\n        // |    0000    |    0    |        table[0] = 0         |\\n        // |    0001    |    1    |        table[1] = 0         |\\n        // |    0010    |    2    |        table[2] = 1         |\\n        // |    0011    |    3    |        table[3] = 1         |\\n        // |    0100    |    4    |        table[4] = 2         |\\n        // |    0101    |    5    |        table[5] = 2         |\\n        // |    0110    |    6    |        table[6] = 2         |\\n        // |    0111    |    7    |        table[7] = 2         |\\n        // |    1000    |    8    |        table[8] = 3         |\\n        // |    1001    |    9    |        table[9] = 3         |\\n        // |    1010    |   10    |        table[10] = 3        |\\n        // |    1011    |   11    |        table[11] = 3        |\\n        // |    1100    |   12    |        table[12] = 3        |\\n        // |    1101    |   13    |        table[13] = 3        |\\n        // |    1110    |   14    |        table[14] = 3        |\\n        // |    1111    |   15    |        table[15] = 3        |\\n        //\\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\\n        assembly (\\\"memory-safe\\\") {\\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 x) internal pure returns (uint256 r) {\\n        // If value has upper 128 bits set, log2 result is at least 128\\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\\n        // If upper 64 bits of 128-bit half set, add 64 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\\n        // If upper 32 bits of 64-bit half set, add 32 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\\n        // If upper 16 bits of 32-bit half set, add 16 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\",\"keccak256\":\"0x1225214420c83ebcca88f2ae2b50f053aaa7df7bd684c3e878d334627f2edfc6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value > type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value > type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value > type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value > type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value > type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value > type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value > type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value > type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value > type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value > type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value > type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value > type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value > type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value > type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value > type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value > type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value > type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value > type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value > type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value > type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value > type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value > type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value > type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value > type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value > type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value > type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value > type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value < 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value > uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n\\n    /**\\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\\n     */\\n    function toUint(bool b) internal pure returns (uint256 u) {\\n        assembly (\\\"memory-safe\\\") {\\n            u := iszero(iszero(b))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x195533c86d0ef72bcc06456a4f66a9b941f38eb403739b00f21fd7c1abd1ae54\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\\n     *\\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\\n     * one branch when needed, making this function more expensive.\\n     */\\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\\n        unchecked {\\n            // branchless ternary works because:\\n            // b ^ (a ^ b) == a\\n            // b ^ 0 == b\\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return ternary(a > b, a, b);\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return ternary(a < b, a, b);\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // Formula from the \\\"Bit Twiddling Hacks\\\" by Sean Eron Anderson.\\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\\n            // taking advantage of the most significant (or \\\"sign\\\" bit) in two's complement representation.\\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\\n            int256 mask = n >> 255;\\n\\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\\n            return uint256((n + mask) ^ mask);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb1970fac7b64e6c09611e6691791e848d5e3fe410fa5899e7df2e0afd77a99e3\",\"license\":\"MIT\"},\"src/EscrowUniversal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/// @authors: [@unknownunknown1, @jaybuidl]\\n/// @reviewers: []\\n/// @auditors: []\\n/// @bounties: []\\n\\npragma solidity 0.8.24;\\n\\nimport {IArbitrableV2, IArbitratorV2} from \\\"@kleros/kleros-v2-contracts/arbitration/interfaces/IArbitrableV2.sol\\\";\\nimport \\\"@kleros/kleros-v2-contracts/arbitration/interfaces/IDisputeTemplateRegistry.sol\\\";\\nimport {SafeERC20, IERC20} from \\\"./libraries/SafeERC20.sol\\\";\\nimport \\\"./interfaces/IEscrow.sol\\\";\\n\\n/// @title EscrowUniversal for a sale paid in native currency or ERC20 tokens without platform fees.\\n/// @dev Adapted from MultipleArbitrableTokenTransaction contract: https://github.com/kleros/kleros-interaction/blob/master/contracts/standard/arbitration/MultipleArbitrableTokenTransaction.sol\\n/// and from MultipleArbitrableTransaction contract: https://github.com/kleros/kleros-interaction/blob/master/contracts/standard/arbitration/MultipleArbitrableTransaction.sol\\n/// Note that the contract expects the tokens to have standard ERC20 behaviour.\\n/// The tokens that don't conform to this type of behaviour should be filtered by the UI.\\n/// Tokens should not reenter or allow recipients to refuse the transfer.\\n/// Also note that arbitration fees are still paid in ETH.\\ncontract EscrowUniversal is IEscrow, IArbitrableV2 {\\n    // Use safe transfers when both parties are paid simultaneously (save for acceptSettlement) to prevent griefing.\\n    using SafeERC20 for IERC20;\\n\\n    // ************************************* //\\n    // *             Storage               * //\\n    // ************************************* //\\n\\n    uint256 public constant AMOUNT_OF_CHOICES = 2;\\n    address public governor;\\n    IArbitratorV2 public arbitrator; // Address of the arbitrator contract.\\n    bytes public arbitratorExtraData; // Extra data to set up the arbitration.\\n    IDisputeTemplateRegistry public templateRegistry; // The dispute template registry.\\n    uint256 public templateId; // The current dispute template identifier.\\n    uint256 public feeTimeout; // Time in seconds a party can take to pay arbitration fees before being considered unresponsive and lose the dispute.\\n    uint256 public settlementTimeout; // Time in seconds a party can take to accept or propose a settlement before being considered unresponsive.\\n    Transaction[] public transactions; // List of all created transactions.\\n    mapping(uint256 => uint256) public disputeIDtoTransactionID; // Naps dispute ID to tx ID.\\n    mapping(IERC20 => uint256) public amountCaps; // Caps the amount of the respective token for the Escrow transaction.\\n\\n    // ************************************* //\\n    // *        Function Modifiers         * //\\n    // ************************************* //\\n\\n    modifier onlyByGovernor() {\\n        if (governor != msg.sender) revert GovernorOnly();\\n        _;\\n    }\\n\\n    modifier shouldNotExceedCap(IERC20 _token, uint256 _amount) {\\n        if (_amount > amountCaps[_token]) revert AmountExceedsCap();\\n        _;\\n    }\\n\\n    // ************************************* //\\n    // *            Constructor            * //\\n    // ************************************* //\\n\\n    /// @dev Constructor.\\n    /// @param _arbitrator The arbitrator of the contract.\\n    /// @param _arbitratorExtraData Extra data for the arbitrator.\\n    /// @param _templateData The dispute template data.\\n    /// @param _templateDataMappings The dispute template data mappings.\\n    /// @param _templateRegistry The dispute template registry.\\n    /// @param _feeTimeout Arbitration fee timeout for the parties.\\n    /// @param _settlementTimeout Settlement timeout for the parties.\\n    constructor(\\n        IArbitratorV2 _arbitrator,\\n        bytes memory _arbitratorExtraData,\\n        string memory _templateData,\\n        string memory _templateDataMappings,\\n        IDisputeTemplateRegistry _templateRegistry,\\n        uint256 _feeTimeout,\\n        uint256 _settlementTimeout\\n    ) {\\n        governor = msg.sender;\\n        arbitrator = _arbitrator;\\n        arbitratorExtraData = _arbitratorExtraData;\\n        templateRegistry = _templateRegistry;\\n        feeTimeout = _feeTimeout;\\n        settlementTimeout = _settlementTimeout;\\n        templateId = templateRegistry.setDisputeTemplate(\\\"\\\", _templateData, _templateDataMappings);\\n\\n        emit ParameterUpdated(_feeTimeout, _settlementTimeout, _arbitratorExtraData);\\n    }\\n\\n    // ************************************* //\\n    // *             Governance            * //\\n    // ************************************* //\\n\\n    function changeGovernor(address _governor) external onlyByGovernor {\\n        governor = _governor;\\n    }\\n\\n    function changeArbitrator(IArbitratorV2 _arbitrator) external onlyByGovernor {\\n        arbitrator = _arbitrator;\\n    }\\n\\n    function changeArbitratorExtraData(bytes calldata _arbitratorExtraData) external onlyByGovernor {\\n        arbitratorExtraData = _arbitratorExtraData;\\n        emit ParameterUpdated(feeTimeout, settlementTimeout, _arbitratorExtraData);\\n    }\\n\\n    function changeTemplateRegistry(IDisputeTemplateRegistry _templateRegistry) external onlyByGovernor {\\n        templateRegistry = _templateRegistry;\\n    }\\n\\n    function changeDisputeTemplate(\\n        string memory _templateData,\\n        string memory _templateDataMappings\\n    ) external onlyByGovernor {\\n        templateId = templateRegistry.setDisputeTemplate(\\\"\\\", _templateData, _templateDataMappings);\\n    }\\n\\n    function changeFeeTimeout(uint256 _feeTimeout) external onlyByGovernor {\\n        feeTimeout = _feeTimeout;\\n        emit ParameterUpdated(_feeTimeout, settlementTimeout, arbitratorExtraData);\\n    }\\n\\n    function changeSettlementTimeout(uint256 _settlementTimeout) external onlyByGovernor {\\n        settlementTimeout = _settlementTimeout;\\n        emit ParameterUpdated(feeTimeout, _settlementTimeout, arbitratorExtraData);\\n    }\\n\\n    function changeAmountCap(IERC20 _token, uint256 _amountCap) external onlyByGovernor {\\n        amountCaps[_token] = _amountCap;\\n    }\\n\\n    // ************************************* //\\n    // *         State Modifiers           * //\\n    // ************************************* //\\n\\n    /// @inheritdoc IEscrow\\n    function createNativeTransaction(\\n        uint256 _deadline,\\n        string memory _transactionUri,\\n        address payable _buyer,\\n        address payable _seller\\n    ) external payable override shouldNotExceedCap(NATIVE, msg.value) returns (uint256 transactionID) {\\n        Transaction storage transaction = transactions.push();\\n        transaction.buyer = _buyer;\\n        transaction.seller = _seller;\\n        transaction.amount = msg.value;\\n        transaction.token = NATIVE;\\n        transaction.deadline = _deadline;\\n\\n        transactionID = transactions.length - 1;\\n\\n        emit NativeTransactionCreated(\\n            transactionID,\\n            _transactionUri,\\n            _buyer,\\n            _seller,\\n            msg.value,\\n            transaction.deadline\\n        );\\n    }\\n\\n    /// @inheritdoc IEscrow\\n    function createERC20Transaction(\\n        uint256 _amount,\\n        IERC20 _token,\\n        uint256 _deadline,\\n        string memory _transactionUri,\\n        address payable _buyer,\\n        address payable _seller\\n    ) external override shouldNotExceedCap(_token, _amount) returns (uint256 transactionID) {\\n        // Transfers token from sender wallet to contract.\\n        if (!_token.safeTransferFrom(msg.sender, address(this), _amount)) revert TokenTransferFailed();\\n        Transaction storage transaction = transactions.push();\\n        transaction.buyer = _buyer;\\n        transaction.seller = _seller;\\n        transaction.amount = _amount;\\n        transaction.token = _token;\\n        transaction.deadline = _deadline;\\n\\n        transactionID = transactions.length - 1;\\n\\n        emit ERC20TransactionCreated(\\n            transactionID,\\n            _transactionUri,\\n            _buyer,\\n            _seller,\\n            _token,\\n            _amount,\\n            transaction.deadline\\n        );\\n    }\\n\\n    /// @inheritdoc IEscrow\\n    function pay(uint256 _transactionID, uint256 _amount) external override {\\n        Transaction storage transaction = transactions[_transactionID];\\n        if (transaction.buyer != msg.sender) revert BuyerOnly();\\n        if (transaction.status != Status.NoDispute) revert TransactionDisputed();\\n        if (_amount > transaction.amount) revert MaximumPaymentAmountExceeded();\\n\\n        emit Payment(_transactionID, _amount, transaction.buyer);\\n\\n        transaction.amount -= _amount;\\n        if (transaction.amount == 0) {\\n            transaction.status = Status.TransactionResolved;\\n            emit TransactionResolved(_transactionID, Resolution.TransactionExecuted);\\n        }\\n\\n        if (transaction.token == NATIVE) {\\n            transaction.seller.send(_amount); // It is the user responsibility to accept ETH.\\n        } else {\\n            if (!transaction.token.safeTransfer(transaction.seller, _amount)) revert TokenTransferFailed();\\n        }\\n    }\\n\\n    /// @inheritdoc IEscrow\\n    function reimburse(uint256 _transactionID, uint256 _amountReimbursed) external override {\\n        Transaction storage transaction = transactions[_transactionID];\\n        if (transaction.seller != msg.sender) revert SellerOnly();\\n        if (transaction.status != Status.NoDispute) revert TransactionDisputed();\\n        if (_amountReimbursed > transaction.amount) revert MaximumPaymentAmountExceeded();\\n\\n        emit Payment(_transactionID, _amountReimbursed, transaction.seller);\\n\\n        transaction.amount -= _amountReimbursed;\\n        if (transaction.amount == 0) {\\n            transaction.status = Status.TransactionResolved;\\n            emit TransactionResolved(_transactionID, Resolution.TransactionExecuted);\\n        }\\n\\n        if (transaction.token == NATIVE) {\\n            transaction.buyer.send(_amountReimbursed); // It is the user responsibility to accept ETH.\\n        } else {\\n            if (!transaction.token.safeTransfer(transaction.buyer, _amountReimbursed)) revert TokenTransferFailed();\\n        }\\n    }\\n\\n    /// @inheritdoc IEscrow\\n    function executeTransaction(uint256 _transactionID) external override {\\n        Transaction storage transaction = transactions[_transactionID];\\n        if (block.timestamp < transaction.deadline) revert DeadlineNotPassed();\\n        if (transaction.status != Status.NoDispute) revert TransactionDisputed();\\n\\n        uint256 amount = transaction.amount;\\n        transaction.amount = 0;\\n        transaction.status = Status.TransactionResolved;\\n\\n        if (transaction.token == NATIVE) {\\n            transaction.seller.send(amount); // It is the user responsibility to accept ETH.\\n        } else {\\n            if (!transaction.token.safeTransfer(transaction.seller, amount)) revert TokenTransferFailed();\\n        }\\n\\n        emit Payment(_transactionID, amount, transaction.buyer);\\n        emit TransactionResolved(_transactionID, Resolution.TransactionExecuted);\\n    }\\n\\n    /// @inheritdoc IEscrow\\n    function proposeSettlement(uint256 _transactionID, uint256 _amount) external override {\\n        Transaction storage transaction = transactions[_transactionID];\\n        if (transaction.status == Status.NoDispute && block.timestamp >= transaction.deadline)\\n            revert TransactionExpired();\\n        if (transaction.status >= Status.WaitingBuyer) revert TransactionEscalatedForArbitration();\\n        if (_amount > transaction.amount) revert MaximumPaymentAmountExceeded();\\n\\n        Party party;\\n        transaction.lastFeePaymentTime = block.timestamp;\\n        if (transaction.status == Status.WaitingSettlementBuyer) {\\n            if (msg.sender != transaction.buyer) revert BuyerOnly();\\n            transaction.settlementBuyer = _amount;\\n            transaction.status = Status.WaitingSettlementSeller;\\n            party = Party.Buyer;\\n        } else if (transaction.status == Status.WaitingSettlementSeller) {\\n            if (msg.sender != transaction.seller) revert SellerOnly();\\n            transaction.settlementSeller = _amount;\\n            transaction.status = Status.WaitingSettlementBuyer;\\n            party = Party.Seller;\\n        } else {\\n            if (msg.sender == transaction.buyer) {\\n                transaction.settlementBuyer = _amount;\\n                transaction.status = Status.WaitingSettlementSeller;\\n                party = Party.Buyer;\\n            } else if (msg.sender == transaction.seller) {\\n                transaction.settlementSeller = _amount;\\n                transaction.status = Status.WaitingSettlementBuyer;\\n                party = Party.Seller;\\n            } else revert BuyerOrSellerOnly();\\n        }\\n        emit SettlementProposed(_transactionID, party, _amount);\\n    }\\n\\n    /// @inheritdoc IEscrow\\n    function acceptSettlement(uint256 _transactionID) external override {\\n        Transaction storage transaction = transactions[_transactionID];\\n        uint256 settlementAmount;\\n        if (transaction.status == Status.WaitingSettlementBuyer) {\\n            if (msg.sender != transaction.buyer) revert BuyerOnly();\\n            settlementAmount = transaction.settlementSeller;\\n        } else if (transaction.status == Status.WaitingSettlementSeller) {\\n            if (msg.sender != transaction.seller) revert SellerOnly();\\n            settlementAmount = transaction.settlementBuyer;\\n        } else revert NoSettlementProposedOrTransactionMovedOnAcceptSettlement();\\n\\n        uint256 remainingAmount = transaction.amount - settlementAmount;\\n\\n        transaction.amount = 0;\\n        transaction.settlementBuyer = 0;\\n        transaction.settlementSeller = 0;\\n        transaction.status = Status.TransactionResolved;\\n\\n        if (transaction.token == NATIVE) {\\n            // It is the users' responsibility to accept ETH.\\n            transaction.buyer.send(remainingAmount);\\n            transaction.seller.send(settlementAmount);\\n        } else {\\n            transaction.token.safeTransfer(transaction.buyer, remainingAmount);\\n            transaction.token.safeTransfer(transaction.seller, settlementAmount);\\n        }\\n\\n        emit TransactionResolved(_transactionID, Resolution.SettlementReached);\\n    }\\n\\n    /// @inheritdoc IEscrow\\n    function payArbitrationFeeByBuyer(uint256 _transactionID) external payable override {\\n        Transaction storage transaction = transactions[_transactionID];\\n        if (\\n            transaction.status != Status.WaitingSettlementBuyer &&\\n            transaction.status != Status.WaitingSettlementSeller &&\\n            transaction.status != Status.WaitingBuyer\\n        ) revert NoSettlementProposedOrTransactionMovedOnPayFeeBuyer();\\n\\n        // Allow the other party enough time to respond to a settlement before allowing the proposer to raise a dispute.\\n        if (\\n            transaction.status == Status.WaitingSettlementSeller &&\\n            block.timestamp - transaction.lastFeePaymentTime < settlementTimeout\\n        ) revert SettlementPeriodNotOver();\\n\\n        if (msg.sender != transaction.buyer) revert BuyerOnly();\\n\\n        transaction.buyerFee += msg.value;\\n        uint256 arbitrationCost = arbitrator.arbitrationCost(arbitratorExtraData);\\n        if (transaction.buyerFee < arbitrationCost) revert BuyerFeeNotCoverArbitrationCosts();\\n\\n        transaction.lastFeePaymentTime = block.timestamp;\\n\\n        if (transaction.sellerFee < arbitrationCost) {\\n            // The seller still has to pay. This can also happen if he has paid, but arbitrationCost has increased.\\n            transaction.status = Status.WaitingSeller;\\n            emit HasToPayFee(_transactionID, Party.Seller);\\n        } else {\\n            // The seller has also paid the fee. We create the dispute.\\n            raiseDispute(_transactionID, arbitrationCost);\\n        }\\n    }\\n\\n    /// @inheritdoc IEscrow\\n    function payArbitrationFeeBySeller(uint256 _transactionID) external payable override {\\n        Transaction storage transaction = transactions[_transactionID];\\n        if (\\n            transaction.status != Status.WaitingSettlementBuyer &&\\n            transaction.status != Status.WaitingSettlementSeller &&\\n            transaction.status != Status.WaitingSeller\\n        ) revert NoSettlementProposedOrTransactionMovedOnPayFeeSeller();\\n\\n        // Allow the other party enough time to respond to a settlement before allowing the proposer to raise a dispute.\\n        if (\\n            transaction.status == Status.WaitingSettlementBuyer &&\\n            block.timestamp - transaction.lastFeePaymentTime < settlementTimeout\\n        ) revert SettlementPeriodNotOver();\\n\\n        if (msg.sender != transaction.seller) revert SellerOnly();\\n\\n        transaction.sellerFee += msg.value;\\n        uint256 arbitrationCost = arbitrator.arbitrationCost(arbitratorExtraData);\\n        if (transaction.sellerFee < arbitrationCost) revert SellerFeeNotCoverArbitrationCosts();\\n\\n        transaction.lastFeePaymentTime = block.timestamp;\\n\\n        if (transaction.buyerFee < arbitrationCost) {\\n            // The buyer still has to pay. This can also happen if he has paid, but arbitrationCost has increased.\\n            transaction.status = Status.WaitingBuyer;\\n            emit HasToPayFee(_transactionID, Party.Buyer);\\n        } else {\\n            // The buyer has also paid the fee. We create the dispute.\\n            raiseDispute(_transactionID, arbitrationCost);\\n        }\\n    }\\n\\n    /// @inheritdoc IEscrow\\n    function timeOutByBuyer(uint256 _transactionID) external override {\\n        Transaction storage transaction = transactions[_transactionID];\\n        if (transaction.status != Status.WaitingSeller) revert NotWaitingForSellerFees();\\n        if (block.timestamp - transaction.lastFeePaymentTime < feeTimeout) revert TimeoutNotPassed();\\n\\n        uint256 amount = transaction.sellerFee;\\n        transaction.sellerFee = 0;\\n\\n        executeRuling(_transactionID, uint256(Party.Buyer));\\n\\n        if (amount != 0) {\\n            transaction.seller.send(amount); // It is the user responsibility to accept ETH.\\n        }\\n\\n        emit TransactionResolved(_transactionID, Resolution.TimeoutByBuyer);\\n    }\\n\\n    /// @inheritdoc IEscrow\\n    function timeOutBySeller(uint256 _transactionID) external override {\\n        Transaction storage transaction = transactions[_transactionID];\\n        if (transaction.status != Status.WaitingBuyer) revert NotWaitingForBuyerFees();\\n        if (block.timestamp - transaction.lastFeePaymentTime < feeTimeout) revert TimeoutNotPassed();\\n\\n        uint256 amount = transaction.buyerFee;\\n        transaction.buyerFee = 0;\\n\\n        executeRuling(_transactionID, uint256(Party.Seller));\\n\\n        if (amount != 0) {\\n            transaction.buyer.send(amount); // It is the user responsibility to accept ETH.\\n        }\\n\\n        emit TransactionResolved(_transactionID, Resolution.TimeoutBySeller);\\n    }\\n\\n    /// @inheritdoc IArbitrableV2\\n    function rule(uint256 _disputeID, uint256 _ruling) external override {\\n        if (msg.sender != address(arbitrator)) revert ArbitratorOnly();\\n        if (_ruling > AMOUNT_OF_CHOICES) revert InvalidRuling();\\n\\n        uint256 transactionID = disputeIDtoTransactionID[_disputeID];\\n        Transaction storage transaction = transactions[transactionID];\\n        if (transaction.status != Status.DisputeCreated) revert DisputeAlreadyResolved();\\n\\n        emit Ruling(arbitrator, _disputeID, _ruling);\\n        emit TransactionResolved(transactionID, Resolution.RulingEnforced);\\n        executeRuling(transactionID, _ruling);\\n    }\\n\\n    // ************************************* //\\n    // *            Internal               * //\\n    // ************************************* //\\n\\n    /// @dev Create a dispute.\\n    /// @param _transactionID The index of the transaction.\\n    /// @param _arbitrationCost Amount to pay the arbitrator.\\n    function raiseDispute(uint256 _transactionID, uint256 _arbitrationCost) internal {\\n        Transaction storage transaction = transactions[_transactionID];\\n        transaction.status = Status.DisputeCreated;\\n        transaction.disputeID = arbitrator.createDispute{value: _arbitrationCost}(\\n            AMOUNT_OF_CHOICES,\\n            arbitratorExtraData\\n        );\\n        disputeIDtoTransactionID[transaction.disputeID] = _transactionID;\\n        uint256 externalDisputeID = uint256(keccak256(abi.encodePacked(address(this), _transactionID)));\\n        emit DisputeRequest(arbitrator, transaction.disputeID, externalDisputeID, templateId, \\\"\\\");\\n\\n        // Refund buyer if he overpaid.\\n        if (transaction.buyerFee > _arbitrationCost) {\\n            uint256 extraFeeBuyer = transaction.buyerFee - _arbitrationCost;\\n            transaction.buyerFee = _arbitrationCost;\\n            transaction.buyer.send(extraFeeBuyer); // It is the user responsibility to accept ETH.\\n        }\\n\\n        // Refund seller if he overpaid.\\n        if (transaction.sellerFee > _arbitrationCost) {\\n            uint256 extraFeeSeller = transaction.sellerFee - _arbitrationCost;\\n            transaction.sellerFee = _arbitrationCost;\\n            transaction.seller.send(extraFeeSeller); // It is the user responsibility to accept ETH.\\n        }\\n    }\\n\\n    /// @dev Execute a ruling of a dispute. It reimburses the fee to the winning party.\\n    /// @param _transactionID The index of the transaction.\\n    /// @param _ruling Ruling given by the arbitrator. 1 : Reimburse the seller. 2 : Pay the buyer.\\n    function executeRuling(uint256 _transactionID, uint256 _ruling) internal {\\n        Transaction storage transaction = transactions[_transactionID];\\n        address payable buyer = transaction.buyer;\\n        address payable seller = transaction.seller;\\n\\n        (uint256 buyerPayout, uint256 buyerPayoutToken, uint256 sellerPayout, uint256 sellerPayoutToken) = getPayouts(\\n            _transactionID,\\n            Party(_ruling)\\n        );\\n\\n        transaction.amount = 0;\\n        transaction.settlementBuyer = 0;\\n        transaction.settlementSeller = 0;\\n        transaction.buyerFee = 0;\\n        transaction.sellerFee = 0;\\n        transaction.status = Status.TransactionResolved;\\n\\n        if (buyerPayout > 0) {\\n            buyer.send(buyerPayout); // It is the user responsibility to accept ETH.\\n        }\\n        if (sellerPayout > 0) {\\n            seller.send(sellerPayout); // It is the user responsibility to accept ETH.\\n        }\\n        if (buyerPayoutToken > 0) {\\n            transaction.token.safeTransfer(buyer, buyerPayoutToken); // Tokens should not reenter or allow recipients to refuse the transfer.\\n        }\\n        if (sellerPayoutToken > 0) {\\n            transaction.token.safeTransfer(seller, sellerPayoutToken); // Tokens should not reenter or allow recipients to refuse the transfer.\\n        }\\n    }\\n\\n    // ************************************* //\\n    // *           Public Views            * //\\n    // ************************************* //\\n\\n    /// @inheritdoc IEscrow\\n    function getTransactionCount() external view override returns (uint256) {\\n        return transactions.length;\\n    }\\n\\n    /// @dev Get the payout depending on the winning party.\\n    /// @dev The cost for the buyer is the seller payout non-inclusive of any arbitration fees.\\n    /// @param _transactionID The index of the transaction.\\n    /// @param _winningParty The winning party.\\n    /// @return buyerPayout The payout for the buyer.\\n    /// @return buyerPayoutToken The payout for the buyer in tokens.\\n    /// @return sellerPayout The payout for the seller.\\n    /// @return sellerPayoutToken The payout for the seller in tokens.\\n    function getPayouts(\\n        uint256 _transactionID,\\n        Party _winningParty\\n    )\\n        public\\n        view\\n        returns (uint256 buyerPayout, uint256 buyerPayoutToken, uint256 sellerPayout, uint256 sellerPayoutToken)\\n    {\\n        Transaction storage transaction = transactions[_transactionID];\\n        uint256 amount = transaction.amount;\\n        uint256 settlementBuyer = transaction.settlementBuyer;\\n        uint256 settlementSeller = transaction.settlementSeller;\\n        uint256 buyerFee = transaction.buyerFee;\\n        uint256 sellerFee = transaction.sellerFee;\\n        bool nativePayment = transaction.token == NATIVE;\\n        if (_winningParty == Party.Buyer) {\\n            // The Seller gets the settlement amount proposed by the Buyer if any, otherwise nothing.\\n            // The Buyer gets the remaining amount of the transaction back if any.\\n            // The Buyer gets the arbitration fee back.\\n            uint256 settledAmount = settlementBuyer;\\n            if (nativePayment) {\\n                buyerPayout = buyerFee + amount - settledAmount;\\n                sellerPayout = settledAmount;\\n            } else {\\n                buyerPayout = buyerFee;\\n                buyerPayoutToken = amount - settledAmount;\\n                sellerPayoutToken = settledAmount;\\n            }\\n        } else if (_winningParty == Party.Seller) {\\n            // The Seller gets his proposed settlement amount if any, otherwise the transaction amount.\\n            // The Buyer gets the remaining amount of the transaction back if any.\\n            // The Seller gets the arbitration fee back.\\n            uint256 settledAmount = settlementSeller != 0 ? settlementSeller : amount;\\n            if (nativePayment) {\\n                buyerPayout = amount - settledAmount;\\n                sellerPayout = sellerFee + settledAmount;\\n            } else {\\n                buyerPayoutToken = amount - settledAmount;\\n                sellerPayout = sellerFee;\\n                sellerPayoutToken = settledAmount;\\n            }\\n        } else {\\n            // No party wins, we split the arbitration fee and the transaction amount.\\n            // The arbitration fee has been paid twice, once by the Buyer and once by the Seller in equal amount once arbitration starts.\\n            // In case of an uneven token amount, one basic token unit can be burnt.\\n            uint256 splitArbitrationFee = buyerFee / 2; // buyerFee equals sellerFee.\\n            buyerPayout = splitArbitrationFee;\\n            sellerPayout = splitArbitrationFee;\\n            uint256 splitAmount = amount / 2;\\n            if (nativePayment) {\\n                buyerPayout += splitAmount;\\n                sellerPayout += splitAmount;\\n            } else {\\n                buyerPayoutToken = splitAmount;\\n                sellerPayoutToken = splitAmount;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0b8b33d43ed21f8ecbd005a1081a9c39f62f74d14524ae62974d08fd4ba794d7\",\"license\":\"MIT\"},\"src/EscrowView.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.24;\\n\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {EscrowUniversal, Transaction, NATIVE, Party, Status, IERC20} from \\\"./EscrowUniversal.sol\\\";\\n\\n/// @title EscrowView\\n/// @notice A view contract for EscrowUniversal to facilitate the display of ruling options.\\ncontract EscrowView {\\n    EscrowUniversal public immutable escrow;\\n\\n    /// @notice Initialize the view contract with the address of the EscrowUniversal contract.\\n    /// @param _escrow The address of the EscrowUniversal contract.\\n    constructor(address _escrow) {\\n        escrow = EscrowUniversal(_escrow);\\n    }\\n\\n    /// @notice Get the payout messages for a transaction *once* a dispute is created.\\n    /// @notice The amounts are exclusive of arbitration fees for clarity.\\n    /// @notice The amounts pre-dispute are imprecise as the arbitration fees are not paid yet by either or both parties.\\n    /// @return noWinner The payout message for the case where nobody wins.\\n    /// @return buyerWins The payout message for the case where the buyer wins.\\n    /// @return sellerWins The payout message for the case where the seller wins.\\n    function getPayoutMessages(\\n        uint256 _transactionID\\n    ) external view returns (string memory noWinner, string memory buyerWins, string memory sellerWins) {\\n        (, , uint256 amount, , , , , uint256 buyerFee, uint256 sellerFee, , , IERC20 token) = escrow.transactions(\\n            _transactionID\\n        );\\n\\n        (uint256 noWinnerPayout, uint256 noWinnerPayoutToken, , ) = escrow.getPayouts(_transactionID, Party.None);\\n        (, , uint256 buyerWinsCost, uint256 buyerWinsCostToken) = escrow.getPayouts(_transactionID, Party.Buyer);\\n        (, , uint256 sellerWinsCost, uint256 sellerWinsCostToken) = escrow.getPayouts(_transactionID, Party.Seller);\\n\\n        if (token == NATIVE) {\\n            string memory amountStr = formatEth(amount);\\n            noWinner = string.concat(\\n                \\\"Buyer and Seller get \\\",\\n                formatEth(noWinnerPayout - (buyerFee / 2)),\\n                \\\" back and half of the arbitration fees.\\\"\\n            );\\n            string memory insteadStr = buyerWinsCost != amount ? string.concat(\\\" instead of \\\", amountStr) : \\\"\\\";\\n            buyerWins = string.concat(\\n                \\\"Buyer pays \\\",\\n                formatEth(buyerWinsCost), // Exclusive of arbitration fees\\n                insteadStr,\\n                \\\", gets the arbitration fees back.\\\"\\n            );\\n            insteadStr = sellerWinsCost - sellerFee != amount ? string.concat(\\\" instead of \\\", amountStr) : \\\"\\\";\\n            sellerWins = string.concat(\\n                \\\"Buyer pays \\\",\\n                formatEth(sellerWinsCost - sellerFee), // Including of arbitration fees, deduct them\\n                insteadStr,\\n                \\\", Seller gets the arbitration fees back.\\\"\\n            );\\n        } else {\\n            string memory amountTokenStr = formatToken(amount, address(token));\\n            noWinner = string.concat(\\n                \\\"Buyer and Seller get \\\",\\n                formatToken(noWinnerPayoutToken, address(token)),\\n                \\\" back and half of the arbitration fees.\\\"\\n            );\\n            string memory insteadStr = buyerWinsCost != amount ? string.concat(\\\" instead of \\\", amountTokenStr) : \\\"\\\";\\n            buyerWins = string.concat(\\n                \\\"Buyer pays \\\",\\n                formatToken(buyerWinsCostToken, address(token)),\\n                insteadStr,\\n                \\\", gets the arbitration fees back.\\\"\\n            );\\n            insteadStr = sellerWinsCost - sellerFee != amount ? string.concat(\\\" instead of \\\", amountTokenStr) : \\\"\\\";\\n            sellerWins = string.concat(\\n                \\\"Buyer pays \\\",\\n                formatToken(sellerWinsCostToken, address(token)),\\n                insteadStr,\\n                \\\", Seller gets the arbitration fees back.\\\"\\n            );\\n        }\\n    }\\n\\n    /// @notice Format an amount in ETH to 3 decimal places.\\n    /// @param _amountWei The amount in wei.\\n    /// @return The formatted amount.\\n    function formatEth(uint256 _amountWei) public pure returns (string memory) {\\n        uint256 ethWhole = _amountWei / 1 ether;\\n        uint256 ethFraction = (_amountWei % 1 ether) / 1e15; // Get the first 3 decimal digits\\n\\n        // Convert the whole and fractional parts to strings\\n        string memory ethWholeStr = Strings.toString(ethWhole);\\n\\n        // If the fractional part is zero, return only the whole part\\n        if (ethFraction == 0) {\\n            return string.concat(ethWholeStr, \\\" ETH\\\");\\n        }\\n\\n        // Convert the fractional part to string with leading zeros if necessary\\n        string memory ethFractionStr = Strings.toString(ethFraction);\\n\\n        // Pad the fractional part with leading zeros to ensure three digits\\n        while (bytes(ethFractionStr).length < 3) {\\n            ethFractionStr = string.concat(\\\"0\\\", ethFractionStr);\\n        }\\n\\n        // Remove trailing zeros from the fractional part\\n        bytes memory fractionBytes = bytes(ethFractionStr);\\n        uint256 fractionLength = fractionBytes.length;\\n        while (fractionLength > 0 && fractionBytes[fractionLength - 1] == \\\"0\\\") {\\n            fractionLength--;\\n        }\\n\\n        if (fractionLength == 0) {\\n            return ethWholeStr;\\n        } else {\\n            bytes memory fractionTrimmed = new bytes(fractionLength);\\n            for (uint256 i = 0; i < fractionLength; i++) {\\n                fractionTrimmed[i] = fractionBytes[i];\\n            }\\n            return string.concat(ethWholeStr, \\\".\\\", string(fractionTrimmed), \\\" ETH\\\");\\n        }\\n    }\\n\\n    /// @notice Format an amount in a token to 3 decimal places.\\n    /// @param _amountWei The amount in wei.\\n    /// @param _token The address of the token.\\n    /// @return The formatted amount.\\n    function formatToken(uint256 _amountWei, address _token) public view returns (string memory) {\\n        require(_token != address(0), \\\"Invalid token address\\\");\\n        IERC20Metadata token = IERC20Metadata(_token);\\n        uint8 decimals = token.decimals();\\n        string memory symbol = token.symbol();\\n\\n        uint256 tenToDecimals = uint256(10) ** uint256(decimals);\\n        uint256 tokenWhole = _amountWei / tenToDecimals;\\n\\n        uint256 tokenFraction;\\n        uint8 fractionDigits;\\n\\n        if (decimals >= 3) {\\n            uint256 divider = uint256(10) ** uint256(decimals - 3);\\n            tokenFraction = (_amountWei % tenToDecimals) / divider;\\n            fractionDigits = 3;\\n        } else {\\n            tokenFraction = _amountWei % tenToDecimals;\\n            fractionDigits = decimals;\\n        }\\n\\n        string memory tokenWholeStr = Strings.toString(tokenWhole);\\n\\n        if (tokenFraction == 0) {\\n            return string.concat(tokenWholeStr, \\\" \\\", symbol);\\n        }\\n\\n        string memory tokenFractionStr = Strings.toString(tokenFraction);\\n\\n        while (bytes(tokenFractionStr).length < fractionDigits) {\\n            tokenFractionStr = string.concat(\\\"0\\\", tokenFractionStr);\\n        }\\n\\n        bytes memory fractionBytes = bytes(tokenFractionStr);\\n        uint256 fractionLength = fractionBytes.length;\\n        while (fractionLength > 0 && fractionBytes[fractionLength - 1] == bytes1(\\\"0\\\")) {\\n            fractionLength--;\\n        }\\n\\n        if (fractionLength == 0) {\\n            return string.concat(tokenWholeStr, \\\" \\\", symbol);\\n        } else {\\n            bytes memory fractionTrimmed = new bytes(fractionLength);\\n            for (uint256 i = 0; i < fractionLength; i++) {\\n                fractionTrimmed[i] = fractionBytes[i];\\n            }\\n            return string.concat(tokenWholeStr, \\\".\\\", string(fractionTrimmed), \\\" \\\", symbol);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xada50eda8604942b4d5e4c19de3aee0fe69cb611b9f9fcc13612669072b152a4\",\"license\":\"MIT\"},\"src/interfaces/IEscrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.24;\\n\\nimport \\\"./Types.sol\\\";\\n\\ninterface IEscrow {\\n    // ************************************* //\\n    // *              Events               * //\\n    // ************************************* //\\n\\n    /// @dev To be emitted when Escrow parameters are updated.\\n    event ParameterUpdated(uint256 _feeTimeout, uint256 _settlementTimeout, bytes _arbitratorExtraData);\\n\\n    /// @dev To be emitted when a party pays or reimburses the other.\\n    /// @param _transactionID The index of the transaction.\\n    /// @param _amount The amount paid.\\n    /// @param _party The party that paid.\\n    event Payment(uint256 indexed _transactionID, uint256 _amount, address _party);\\n\\n    /// @dev Indicate that a party has to pay a fee or would otherwise be considered as losing.\\n    /// @param _transactionID The index of the transaction.\\n    /// @param _party The party who has to pay.\\n    event HasToPayFee(uint256 indexed _transactionID, Party _party);\\n\\n    /// @dev Emitted when a party proposes a settlement.\\n    /// @param _transactionID The index of the transaction.\\n    /// @param _party The party that proposed a settlement.\\n    /// @param _amount The amount proposed.\\n    event SettlementProposed(uint256 indexed _transactionID, Party _party, uint256 _amount);\\n\\n    /// @dev Emitted when a transaction paid in native currency is created.\\n    /// @param _transactionID The index of the transaction.\\n    /// @param _transactionUri The IPFS Uri Hash of the transaction.\\n    /// @param _buyer The address of the buyer.\\n    /// @param _seller The address of the seller.\\n    /// @param _amount The initial amount in the transaction.\\n    /// @param _deadline The deadline of the transaction.\\n    event NativeTransactionCreated(\\n        uint256 indexed _transactionID,\\n        string _transactionUri,\\n        address indexed _buyer,\\n        address indexed _seller,\\n        uint256 _amount,\\n        uint256 _deadline\\n    );\\n\\n    /// @dev Emitted when a transaction paid in ERC20 token is created.\\n    /// @param _transactionID The index of the transaction.\\n    /// @param _transactionUri The IPFS Uri Hash of the transaction.\\n    /// @param _buyer The address of the buyer.\\n    /// @param _seller The address of the seller.\\n    /// @param _token The token address.\\n    /// @param _amount The initial amount in the transaction.\\n    /// @param _deadline The deadline of the transaction.\\n    event ERC20TransactionCreated(\\n        uint256 indexed _transactionID,\\n        string _transactionUri,\\n        address indexed _buyer,\\n        address indexed _seller,\\n        IERC20 _token,\\n        uint256 _amount,\\n        uint256 _deadline\\n    );\\n\\n    /// @dev To be emitted when a transaction is resolved, either by its\\n    ///      execution, a timeout or because a ruling was enforced.\\n    /// @param _transactionID The ID of the respective transaction.\\n    /// @param _resolution Short description of what caused the transaction to be solved.\\n    event TransactionResolved(uint256 indexed _transactionID, Resolution indexed _resolution);\\n\\n    // ************************************* //\\n    // *         State Modifiers           * //\\n    // ************************************* //\\n\\n    /// @dev Create a transaction.\\n    /// @param _deadline Time after which a party can automatically execute the arbitrable transaction.\\n    /// @param _transactionUri The IPFS Uri Hash of the transaction.\\n    /// @param _buyer Party that pays for the transaction. Note that msg.sender can provide finds on their behalf.\\n    /// @param _seller The recipient of the transaction.\\n    /// @return transactionID The index of the transaction.\\n    function createNativeTransaction(\\n        uint256 _deadline,\\n        string memory _transactionUri,\\n        address payable _buyer,\\n        address payable _seller\\n    ) external payable returns (uint256 transactionID);\\n\\n    /// @dev Create a transaction.\\n    /// @param _amount The amount of tokens in this transaction.\\n    /// @param _token The ERC20 token contract.\\n    /// @param _deadline Time after which a party can automatically execute the arbitrable transaction.\\n    /// @param _transactionUri The IPFS Uri Hash of the transaction.\\n    /// @param _buyer Party that pays for the transaction. Note that msg.sender can provide finds on their behalf.\\n    /// @param _seller The recipient of the transaction.\\n    /// @return transactionID The index of the transaction.\\n    function createERC20Transaction(\\n        uint256 _amount,\\n        IERC20 _token,\\n        uint256 _deadline,\\n        string memory _transactionUri,\\n        address payable _buyer,\\n        address payable _seller\\n    ) external returns (uint256 transactionID);\\n\\n    /// @dev Pay seller. To be called if the good or service is provided.\\n    /// @param _transactionID The index of the transaction.\\n    /// @param _amount Amount to pay in wei.\\n    function pay(uint256 _transactionID, uint256 _amount) external;\\n\\n    /// @dev Reimburse buyer. To be called if the good or service can't be fully provided.\\n    /// @param _transactionID The index of the transaction.\\n    /// @param _amountReimbursed Amount to reimburse in wei.\\n    function reimburse(uint256 _transactionID, uint256 _amountReimbursed) external;\\n\\n    /// @dev Transfer the transaction's amount to the seller if the timeout has passed.\\n    /// @param _transactionID The index of the transaction.\\n    function executeTransaction(uint256 _transactionID) external;\\n\\n    ///  @dev Propose a settlement as a compromise from the initial terms to the other party.\\n    ///  Note that a party can only propose a settlement again after the other party has\\n    ///  done so as well to prevent front running/griefing issues.\\n    ///  @param _transactionID The index of the transaction.\\n    ///  @param _amount The settlement amount.\\n    function proposeSettlement(uint256 _transactionID, uint256 _amount) external;\\n\\n    /// @dev Accept a settlement proposed by the other party.\\n    /// @param _transactionID The index of the transaction.\\n    function acceptSettlement(uint256 _transactionID) external;\\n\\n    /// @dev Pay the arbitration fee to raise a dispute. To be called by the buyer.\\n    /// Note that it can only be called after settlement proposition.\\n    /// Also note that the arbitrator can have createDispute throw, which will make\\n    ///      this function throw and therefore lead to a party being timed-out.\\n    ///      This is not a vulnerability as the arbitrator can rule in favor of one party anyway.\\n    /// @param _transactionID The index of the transaction.\\n    function payArbitrationFeeByBuyer(uint256 _transactionID) external payable;\\n\\n    /// @dev Pay the arbitration fee to raise a dispute. To be called by the seller.\\n    /// Note that this function mirrors payArbitrationFeeByBuyer.\\n    /// @param _transactionID The index of the transaction.\\n    function payArbitrationFeeBySeller(uint256 _transactionID) external payable;\\n\\n    /// @dev Reimburse buyer if seller fails to pay the fee.\\n    /// @param _transactionID The index of the transaction.\\n    function timeOutByBuyer(uint256 _transactionID) external;\\n\\n    /// @dev Pay seller if buyer fails to pay the fee.\\n    /// @param _transactionID The index of the transaction.\\n    function timeOutBySeller(uint256 _transactionID) external;\\n\\n    // ************************************* //\\n    // *           Public Views            * //\\n    // ************************************* //\\n\\n    /// @dev Getter to know the count of transactions.\\n    /// @return The count of transactions.\\n    function getTransactionCount() external view returns (uint256);\\n\\n    // ************************************* //\\n    // *              Errors               * //\\n    // ************************************* //\\n\\n    error GovernorOnly();\\n    error BuyerOnly();\\n    error SellerOnly();\\n    error BuyerOrSellerOnly();\\n    error ArbitratorOnly();\\n    error TransactionDisputed();\\n    error MaximumPaymentAmountExceeded();\\n    error DeadlineNotPassed();\\n    error BuyerFeeNotCoverArbitrationCosts();\\n    error SellerFeeNotCoverArbitrationCosts();\\n    error NotWaitingForSellerFees();\\n    error NotWaitingForBuyerFees();\\n    error TimeoutNotPassed();\\n    error InvalidRuling();\\n    error DisputeAlreadyResolved();\\n    error TransactionExpired();\\n    error TransactionEscalatedForArbitration();\\n    error NoSettlementProposedOrTransactionMovedOnAcceptSettlement();\\n    error NoSettlementProposedOrTransactionMovedOnPayFeeBuyer();\\n    error NoSettlementProposedOrTransactionMovedOnPayFeeSeller();\\n    error SettlementPeriodNotOver();\\n    error NotSupported();\\n    error TokenTransferFailed();\\n    error AmountExceedsCap();\\n}\\n\",\"keccak256\":\"0x0205e7064883b850e7b434286629c776d61bfb83258e452e46eff0c8a6bdb2a3\",\"license\":\"MIT\"},\"src/interfaces/Types.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport {IERC20} from \\\"../libraries/SafeERC20.sol\\\";\\n\\nIERC20 constant NATIVE = IERC20(address(0));\\n\\nenum Party {\\n    None,\\n    Buyer, // Makes a purchase in native currency or ERC20 token.\\n    Seller // Provides a good or service in exchange for native currency or ERC20 token.\\n}\\n\\nenum Status {\\n    NoDispute,\\n    WaitingSettlementBuyer,\\n    WaitingSettlementSeller,\\n    WaitingBuyer,\\n    WaitingSeller,\\n    DisputeCreated,\\n    TransactionResolved\\n}\\n\\nenum Resolution {\\n    TransactionExecuted,\\n    TimeoutByBuyer,\\n    TimeoutBySeller,\\n    RulingEnforced,\\n    SettlementReached\\n}\\n\\nstruct Transaction {\\n    address payable buyer;\\n    address payable seller;\\n    uint256 amount;\\n    uint256 settlementBuyer; // Settlement amount proposed by the buyer.\\n    uint256 settlementSeller; // Settlement amount proposed by the seller.\\n    uint256 deadline; // Timestamp at which the transaction can be automatically executed if not disputed.\\n    uint256 disputeID; // If dispute exists, the ID of the dispute.\\n    uint256 buyerFee; // Total fees paid by the buyer.\\n    uint256 sellerFee; // Total fees paid by the seller.\\n    uint256 lastFeePaymentTime; // Last time the dispute fees were paid by either party or settlement proposed.\\n    Status status;\\n    IERC20 token; // Token to pay the seller with.\\n}\\n\",\"keccak256\":\"0xa35119fdfdeb0f514e8c996d115303f916a95eff6003fdb9c1a8540f64d21ddb\",\"license\":\"MIT\"},\"src/libraries/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a7a94c77463acea95d979aae1580fb0ddc3b6a1e/contracts/token/ERC20/utils/SafeERC20.sol\\n\\npragma solidity 0.8.24;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title SafeERC20\\n/// @dev Wrappers around ERC20 operations that throw on failure (when the token\\n/// contract returns false). Tokens that return no value (and instead revert or\\n/// throw on failure) are also supported, non-reverting calls are assumed to be\\n/// successful.\\n/// To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n/// which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\nlibrary SafeERC20 {\\n    /// @dev Calls transfer() without reverting.\\n    /// @param _token Token to transfer.\\n    /// @param _to Recepient address.\\n    /// @param _value Amount transferred.\\n    /// @return Whether transfer succeeded or not.\\n    function safeTransfer(IERC20 _token, address _to, uint256 _value) internal returns (bool) {\\n        (bool success, bytes memory data) = address(_token).call(abi.encodeCall(IERC20.transfer, (_to, _value)));\\n        return (success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n\\n    /// @dev Calls transferFrom() without reverting.\\n    /// @param _token Token to transfer.\\n    /// @param _from Sender address.\\n    /// @param _to Recepient address.\\n    /// @param _value Amount transferred.\\n    /// @return Whether transfer succeeded or not.\\n    function safeTransferFrom(IERC20 _token, address _from, address _to, uint256 _value) internal returns (bool) {\\n        (bool success, bytes memory data) = address(_token).call(\\n            abi.encodeCall(IERC20.transferFrom, (_from, _to, _value))\\n        );\\n        return (success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n}\",\"keccak256\":\"0x3a53cfe0db97fcacb3a92c085bd9d7dfe86cc3005021dfd7c372374ab13f8e84\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a03461007257601f61107038819003918201601f19168301916001600160401b038311848410176100775780849260209460405283398101031261007257516001600160a01b0381169081900361007257608052604051610fe2908161008e8239608051818181606101526101360152f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe60806040818152600436101561001457600080fd5b600091823560e01c90816366fb66751461010457508063b71dc2ba146100e3578063d65e9334146100945763e2fdcc171461004e57600080fd5b34610090578160031936011261009057517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b5080fd5b5034610090578060031936011261009057602435916001600160a01b03831683036100e057506100c96100dc92600435610afe565b9051918291602083526020830190610506565b0390f35b80fd5b5034610090576020366003190112610090576100dc906100c96004356108a8565b83833461009057602036600319011261009057634d671c6160e11b835260048035908401819052926001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811693909161018091908281602481895afa9586156104d957829683928495859261045b575b505086519163438fdfc360e11b918284528a60048501528560248501526080978885604481865afa9182156104515760249b9c8896899461042a575b5060018c519d8e88815283600482015201528a8d604481885afa95861561042057899d8a976103f0575b509060448c928e51978893849283526004830152600260248301525afa9384156103e657889a89956103ac575b50501690816102fe57505050509361029d61025489956102c5956102a29561027d61025e6102596102b79f6100dc9e9d61024a610254926108a8565b9560011c9061072a565b6108a8565b6105ba565b9c8a81146102e7576102786102728461065b565b916108a8565b61069e565b98610288848861072a565b146102d257610297915061065b565b9361072a565b61074d565b915b8351968796606088526060880190610506565b908682036020880152610506565b9184830390850152610506565b508851906102df8261052b565b81529361072a565b6102788c516102f58161052b565b858152916108a8565b899897999550819396919294508b83916103188383610afe565b9261032291610afe565b61032b906105ba565b9b14156000149b61036b6100dc9b6103656102b79f9a61037a9a61029d996102c59d61039557610278915061035f8861065b565b92610afe565b9a61072a565b146103805761035f915061065b565b916102a4565b5087519061038d8261052b565b815292610afe565b61027891516103a38161052b565b89815292610afe565b6103d1939b508091929550903d106103df575b6103c9818361055d565b810190610598565b9a9250905098928d8061020e565b503d6103bf565b8b513d8a823e3d90fd5b8c92919e508d9750610410604491843d86116103df576103c9818361055d565b925090509f9098509192506101e1565b8c513d8b823e3d90fd5b9093506104459196508a3d8c116103df576103c9818361055d565b5050959095928e6101b7565b8a513d89823e3d90fd5b9350945050955082813d83116104d2575b610476818361055d565b810103126100e0576104878261057f565b506104946020830161057f565b50838201519160e08101519561010082015191600761014082015110156104ce5761016001519385851685036104ce57969193898061017b565b8380fd5b503d61046c565b85513d84823e3d90fd5b60005b8381106104f65750506000910152565b81810151838201526020016104e6565b9060209161051f815180928185528580860191016104e3565b601f01601f1916010190565b6020810190811067ffffffffffffffff82111761054757604052565b634e487b7160e01b600052604160045260246000fd5b90601f8019910116810190811067ffffffffffffffff82111761054757604052565b51906001600160a01b038216820361059357565b600080fd5b9190826080910312610593578151916020810151916060604083015192015190565b9061063d605c6040518094740213abcb2b91030b7321029b2b63632b91033b2ba1605d1b60208301526105f78151809260206035860191016104e3565b81017f206261636b20616e642068616c66206f6620746865206172626974726174696f60358201526637103332b2b99760c91b605582015203603c81018552018361055d565b565b67ffffffffffffffff811161054757601f01601f191660200190565b9061063d602c60405180946b01034b739ba32b0b21037b3160a51b602083015261068e81518092602086860191016104e3565b810103600c81018552018361055d565b604c61063d919392936040519485916a0213abcb2b9103830bcb9960ad1b60208401526106d5815180926020602b870191016104e3565b82016106eb825180936020602b850191016104e3565b017f2c206765747320746865206172626974726174696f6e2066656573206261636b602b820152601760f91b604b82015203602c81018552018361055d565b9190820391821161073757565b634e487b7160e01b600052601160045260246000fd5b605361063d919392936040519485916a0213abcb2b9103830bcb9960ad1b6020840152610784815180926020602b870191016104e3565b820161079a825180936020602b850191016104e3565b017f2c2053656c6c6572206765747320746865206172626974726174696f6e206665602b8201526732b9903130b1b59760c11b604b82015203603381018552018361055d565b81156107ea570490565b634e487b7160e01b600052601260045260246000fd5b81156107ea570690565b9061063d60216040518094600360fc1b602083015261083281518092602086860191016104e3565b810103600181018552018361055d565b908151811015610853570160200190565b634e487b7160e01b600052603260045260246000fd5b8015610737576000190190565b906108808261063f565b61088d604051918261055d565b828152809261089e601f199161063f565b0190602036910137565b6108c7670de0b6b3a764000066038d7ea4c68000818406049204610e48565b908015610a04576108d790610e48565b6003815110156108ef576108ea9061080a565b6108d7565b80515b801515806109c0575b1561090e5761090990610869565b6108f2565b9091908061091c5750905090565b61092581610876565b9260009060005b838110610995575050505060256109929160405193816109568693518092602080870191016104e3565b8201601760f91b60208201526109768251809360206021850191016104e3565b01630408aa8960e31b602182015203600581018452018261055d565b90565b6001906001600160f81b03196109ab8285610842565b5116841a6109b98289610842565b530161092c565b5060001981018181116109ef57600360fc1b906001600160f81b0319906109e79085610842565b5116146108fb565b60246000634e487b7160e01b81526011600452fd5b50610992602460405183610a228295518092602080860191016104e3565b8101630408aa8960e31b602082015203600481018452018261055d565b8015610aa857600190602081108216604e8210831617610aa0578190600a925b808211610a7757505081600019048111610737570290565b90928060001904811161073757818416610a97575b800292811c90610a5f565b80920291610a8c565b9050600a0a90565b50600190565b602161063d919392936040519481610ad08793518092602080870191016104e3565b8201600160fd1b6020820152610aef82518093602087850191016104e3565b0103600181018552018361055d565b916001600160a01b03909116908115610e0b576040805163313ce56760e01b81526004939160209081838781875afa928315610dc357600093610dce575b5060006004948251958680926395d89b4160e01b82525afa938415610dc357600094610d46575b5060ff9660ff841690610b7582610a3f565b91610b8083836107e0565b9560038210610d2f57506002190160ff811161073757610bb492610ba960ff610baf9316610a3f565b92610800565b6107e0565b92610bc0600391610e48565b938015610d1d57610bd090610e48565b80518983161115610be957610be49061080a565b610bd0565b97505086515b80151580610cd9575b15610c0b57610c0690610869565b610bef565b92939495508215600014610c2757505050610992929350610aae565b610c32839593610876565b9460005b818110610cad5750506109929495965090610c9e6022949392519684610c65899651809286808a0191016104e3565b8501601760f91b84820152610c8382518093866021850191016104e3565b0191600160fd1b6021840152835193849187850191016104e3565b0103600281018452018261055d565b6001906001600160f81b0319610cc3828c610842565b511660001a610cd2828a610842565b5301610c36565b506000198101818111610d0857600360fc1b906001600160f81b031990610d00908b610842565b511614610bf8565b601188634e487b7160e01b6000525260246000fd5b50505050909193506109929250610aae565b9592610d3f9150610bc092610800565b9491610e48565b90933d8082843e610d57818461055d565b82019183818403126100905780519067ffffffffffffffff8211610dbf570182601f8201121561009057805191610d8d8361063f565b93610d9a8851958661055d565b8385528584840101116100e0575090610db8918480850191016104e3565b9238610b63565b8280fd5b50513d6000823e3d90fd5b8281819593943d8311610e04575b610de6818361055d565b8101031261009057519060ff821682036100e0575091906000610b3c565b503d610ddc565b60405162461bcd60e51b8152602060048201526015602482015274496e76616c696420746f6b656e206164647265737360581b6044820152606490fd5b6000908072184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b80821015610f9e575b506d04ee2d6d415b85acef810000000080831015610f8f575b50662386f26fc1000080831015610f80575b506305f5e10080831015610f71575b5061271080831015610f62575b506064821015610f52575b600a80921015610f48575b6001908160216001860195610edd8761063f565b96610eeb604051988961055d565b808852610efa601f199161063f565b01366020890137860101905b610f12575b5050505090565b600019019083906f181899199a1a9b1b9c1cb0b131b232b360811b8282061a835304918215610f4357919082610f06565b610f0b565b9160010191610ec9565b9190606460029104910191610ebe565b60049193920491019138610eb3565b60089193920491019138610ea6565b60109193920491019138610e97565b60209193920491019138610e85565b604093508104915038610e6c56fea2646970667358221220dea60be5bebff9d52f2851149fd47dd3f3ce29abe68083fa8e699a42baf9f4f564736f6c63430008180033",
  "deployedBytecode": "0x60806040818152600436101561001457600080fd5b600091823560e01c90816366fb66751461010457508063b71dc2ba146100e3578063d65e9334146100945763e2fdcc171461004e57600080fd5b34610090578160031936011261009057517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b5080fd5b5034610090578060031936011261009057602435916001600160a01b03831683036100e057506100c96100dc92600435610afe565b9051918291602083526020830190610506565b0390f35b80fd5b5034610090576020366003190112610090576100dc906100c96004356108a8565b83833461009057602036600319011261009057634d671c6160e11b835260048035908401819052926001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811693909161018091908281602481895afa9586156104d957829683928495859261045b575b505086519163438fdfc360e11b918284528a60048501528560248501526080978885604481865afa9182156104515760249b9c8896899461042a575b5060018c519d8e88815283600482015201528a8d604481885afa95861561042057899d8a976103f0575b509060448c928e51978893849283526004830152600260248301525afa9384156103e657889a89956103ac575b50501690816102fe57505050509361029d61025489956102c5956102a29561027d61025e6102596102b79f6100dc9e9d61024a610254926108a8565b9560011c9061072a565b6108a8565b6105ba565b9c8a81146102e7576102786102728461065b565b916108a8565b61069e565b98610288848861072a565b146102d257610297915061065b565b9361072a565b61074d565b915b8351968796606088526060880190610506565b908682036020880152610506565b9184830390850152610506565b508851906102df8261052b565b81529361072a565b6102788c516102f58161052b565b858152916108a8565b899897999550819396919294508b83916103188383610afe565b9261032291610afe565b61032b906105ba565b9b14156000149b61036b6100dc9b6103656102b79f9a61037a9a61029d996102c59d61039557610278915061035f8861065b565b92610afe565b9a61072a565b146103805761035f915061065b565b916102a4565b5087519061038d8261052b565b815292610afe565b61027891516103a38161052b565b89815292610afe565b6103d1939b508091929550903d106103df575b6103c9818361055d565b810190610598565b9a9250905098928d8061020e565b503d6103bf565b8b513d8a823e3d90fd5b8c92919e508d9750610410604491843d86116103df576103c9818361055d565b925090509f9098509192506101e1565b8c513d8b823e3d90fd5b9093506104459196508a3d8c116103df576103c9818361055d565b5050959095928e6101b7565b8a513d89823e3d90fd5b9350945050955082813d83116104d2575b610476818361055d565b810103126100e0576104878261057f565b506104946020830161057f565b50838201519160e08101519561010082015191600761014082015110156104ce5761016001519385851685036104ce57969193898061017b565b8380fd5b503d61046c565b85513d84823e3d90fd5b60005b8381106104f65750506000910152565b81810151838201526020016104e6565b9060209161051f815180928185528580860191016104e3565b601f01601f1916010190565b6020810190811067ffffffffffffffff82111761054757604052565b634e487b7160e01b600052604160045260246000fd5b90601f8019910116810190811067ffffffffffffffff82111761054757604052565b51906001600160a01b038216820361059357565b600080fd5b9190826080910312610593578151916020810151916060604083015192015190565b9061063d605c6040518094740213abcb2b91030b7321029b2b63632b91033b2ba1605d1b60208301526105f78151809260206035860191016104e3565b81017f206261636b20616e642068616c66206f6620746865206172626974726174696f60358201526637103332b2b99760c91b605582015203603c81018552018361055d565b565b67ffffffffffffffff811161054757601f01601f191660200190565b9061063d602c60405180946b01034b739ba32b0b21037b3160a51b602083015261068e81518092602086860191016104e3565b810103600c81018552018361055d565b604c61063d919392936040519485916a0213abcb2b9103830bcb9960ad1b60208401526106d5815180926020602b870191016104e3565b82016106eb825180936020602b850191016104e3565b017f2c206765747320746865206172626974726174696f6e2066656573206261636b602b820152601760f91b604b82015203602c81018552018361055d565b9190820391821161073757565b634e487b7160e01b600052601160045260246000fd5b605361063d919392936040519485916a0213abcb2b9103830bcb9960ad1b6020840152610784815180926020602b870191016104e3565b820161079a825180936020602b850191016104e3565b017f2c2053656c6c6572206765747320746865206172626974726174696f6e206665602b8201526732b9903130b1b59760c11b604b82015203603381018552018361055d565b81156107ea570490565b634e487b7160e01b600052601260045260246000fd5b81156107ea570690565b9061063d60216040518094600360fc1b602083015261083281518092602086860191016104e3565b810103600181018552018361055d565b908151811015610853570160200190565b634e487b7160e01b600052603260045260246000fd5b8015610737576000190190565b906108808261063f565b61088d604051918261055d565b828152809261089e601f199161063f565b0190602036910137565b6108c7670de0b6b3a764000066038d7ea4c68000818406049204610e48565b908015610a04576108d790610e48565b6003815110156108ef576108ea9061080a565b6108d7565b80515b801515806109c0575b1561090e5761090990610869565b6108f2565b9091908061091c5750905090565b61092581610876565b9260009060005b838110610995575050505060256109929160405193816109568693518092602080870191016104e3565b8201601760f91b60208201526109768251809360206021850191016104e3565b01630408aa8960e31b602182015203600581018452018261055d565b90565b6001906001600160f81b03196109ab8285610842565b5116841a6109b98289610842565b530161092c565b5060001981018181116109ef57600360fc1b906001600160f81b0319906109e79085610842565b5116146108fb565b60246000634e487b7160e01b81526011600452fd5b50610992602460405183610a228295518092602080860191016104e3565b8101630408aa8960e31b602082015203600481018452018261055d565b8015610aa857600190602081108216604e8210831617610aa0578190600a925b808211610a7757505081600019048111610737570290565b90928060001904811161073757818416610a97575b800292811c90610a5f565b80920291610a8c565b9050600a0a90565b50600190565b602161063d919392936040519481610ad08793518092602080870191016104e3565b8201600160fd1b6020820152610aef82518093602087850191016104e3565b0103600181018552018361055d565b916001600160a01b03909116908115610e0b576040805163313ce56760e01b81526004939160209081838781875afa928315610dc357600093610dce575b5060006004948251958680926395d89b4160e01b82525afa938415610dc357600094610d46575b5060ff9660ff841690610b7582610a3f565b91610b8083836107e0565b9560038210610d2f57506002190160ff811161073757610bb492610ba960ff610baf9316610a3f565b92610800565b6107e0565b92610bc0600391610e48565b938015610d1d57610bd090610e48565b80518983161115610be957610be49061080a565b610bd0565b97505086515b80151580610cd9575b15610c0b57610c0690610869565b610bef565b92939495508215600014610c2757505050610992929350610aae565b610c32839593610876565b9460005b818110610cad5750506109929495965090610c9e6022949392519684610c65899651809286808a0191016104e3565b8501601760f91b84820152610c8382518093866021850191016104e3565b0191600160fd1b6021840152835193849187850191016104e3565b0103600281018452018261055d565b6001906001600160f81b0319610cc3828c610842565b511660001a610cd2828a610842565b5301610c36565b506000198101818111610d0857600360fc1b906001600160f81b031990610d00908b610842565b511614610bf8565b601188634e487b7160e01b6000525260246000fd5b50505050909193506109929250610aae565b9592610d3f9150610bc092610800565b9491610e48565b90933d8082843e610d57818461055d565b82019183818403126100905780519067ffffffffffffffff8211610dbf570182601f8201121561009057805191610d8d8361063f565b93610d9a8851958661055d565b8385528584840101116100e0575090610db8918480850191016104e3565b9238610b63565b8280fd5b50513d6000823e3d90fd5b8281819593943d8311610e04575b610de6818361055d565b8101031261009057519060ff821682036100e0575091906000610b3c565b503d610ddc565b60405162461bcd60e51b8152602060048201526015602482015274496e76616c696420746f6b656e206164647265737360581b6044820152606490fd5b6000908072184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b80821015610f9e575b506d04ee2d6d415b85acef810000000080831015610f8f575b50662386f26fc1000080831015610f80575b506305f5e10080831015610f71575b5061271080831015610f62575b506064821015610f52575b600a80921015610f48575b6001908160216001860195610edd8761063f565b96610eeb604051988961055d565b808852610efa601f199161063f565b01366020890137860101905b610f12575b5050505090565b600019019083906f181899199a1a9b1b9c1cb0b131b232b360811b8282061a835304918215610f4357919082610f06565b610f0b565b9160010191610ec9565b9190606460029104910191610ebe565b60049193920491019138610eb3565b60089193920491019138610ea6565b60109193920491019138610e97565b60209193920491019138610e85565b604093508104915038610e6c56fea2646970667358221220dea60be5bebff9d52f2851149fd47dd3f3ce29abe68083fa8e699a42baf9f4f564736f6c63430008180033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "_escrow": "The address of the EscrowUniversal contract."
        }
      },
      "formatEth(uint256)": {
        "params": {
          "_amountWei": "The amount in wei."
        },
        "returns": {
          "_0": "The formatted amount."
        }
      },
      "formatToken(uint256,address)": {
        "params": {
          "_amountWei": "The amount in wei.",
          "_token": "The address of the token."
        },
        "returns": {
          "_0": "The formatted amount."
        }
      },
      "getPayoutMessages(uint256)": {
        "returns": {
          "buyerWins": "The payout message for the case where the buyer wins.",
          "noWinner": "The payout message for the case where nobody wins.",
          "sellerWins": "The payout message for the case where the seller wins."
        }
      }
    },
    "title": "EscrowView",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "Initialize the view contract with the address of the EscrowUniversal contract."
      },
      "formatEth(uint256)": {
        "notice": "Format an amount in ETH to 3 decimal places."
      },
      "formatToken(uint256,address)": {
        "notice": "Format an amount in a token to 3 decimal places."
      },
      "getPayoutMessages(uint256)": {
        "notice": "Get the payout messages for a transaction *once* a dispute is created.The amounts are exclusive of arbitration fees for clarity.The amounts pre-dispute are imprecise as the arbitration fees are not paid yet by either or both parties."
      }
    },
    "notice": "A view contract for EscrowUniversal to facilitate the display of ruling options.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}